// Code generated by mocker. DO NOT EDIT.
// github.com/travisjeffery/mocker
// Source: api_default.go

package mock

import (
	context "context"
	net_http "net/http"
	sync "sync"

	github_com_confluentinc_schema_registry_sdk_go "github.com/confluentinc/schema-registry-sdk-go"
)

// DefaultApi is a mock of DefaultApi interface
type DefaultApi struct {
	lockAsyncapiPut sync.Mutex
	AsyncapiPutFunc func(ctx context.Context) (*net_http.Response, error)

	lockCreateBusinessMetadata sync.Mutex
	CreateBusinessMetadataFunc func(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.CreateBusinessMetadataOpts) ([]github_com_confluentinc_schema_registry_sdk_go.BusinessMetadataResponse, *net_http.Response, error)

	lockCreateBusinessMetadataDefs sync.Mutex
	CreateBusinessMetadataDefsFunc func(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.CreateBusinessMetadataDefsOpts) ([]github_com_confluentinc_schema_registry_sdk_go.BusinessMetadataDefResponse, *net_http.Response, error)

	lockCreateExporter sync.Mutex
	CreateExporterFunc func(ctx context.Context, body github_com_confluentinc_schema_registry_sdk_go.CreateExporterRequest) (github_com_confluentinc_schema_registry_sdk_go.CreateExporterResponse, *net_http.Response, error)

	lockCreateOrUpdate sync.Mutex
	CreateOrUpdateFunc func(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.CreateOrUpdateOpts) (*net_http.Response, error)

	lockCreateTagDefs sync.Mutex
	CreateTagDefsFunc func(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.CreateTagDefsOpts) ([]github_com_confluentinc_schema_registry_sdk_go.TagDefResponse, *net_http.Response, error)

	lockCreateTags sync.Mutex
	CreateTagsFunc func(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.CreateTagsOpts) ([]github_com_confluentinc_schema_registry_sdk_go.TagResponse, *net_http.Response, error)

	lockDeleteBusinessMetadata sync.Mutex
	DeleteBusinessMetadataFunc func(ctx context.Context, typeName, qualifiedName, bmName string) (*net_http.Response, error)

	lockDeleteBusinessMetadataDef sync.Mutex
	DeleteBusinessMetadataDefFunc func(ctx context.Context, bmName string) (*net_http.Response, error)

	lockDeleteByUniqueAttributes sync.Mutex
	DeleteByUniqueAttributesFunc func(ctx context.Context, typeName, qualifiedName string) (*net_http.Response, error)

	lockDeleteExporter sync.Mutex
	DeleteExporterFunc func(ctx context.Context, name string) (*net_http.Response, error)

	lockDeleteSchemaVersion sync.Mutex
	DeleteSchemaVersionFunc func(ctx context.Context, subject, version string, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.DeleteSchemaVersionOpts) (int32, *net_http.Response, error)

	lockDeleteSubject sync.Mutex
	DeleteSubjectFunc func(ctx context.Context, subject string, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.DeleteSubjectOpts) ([]int32, *net_http.Response, error)

	lockDeleteSubjectConfig sync.Mutex
	DeleteSubjectConfigFunc func(ctx context.Context, subject string) (string, *net_http.Response, error)

	lockDeleteSubjectMode sync.Mutex
	DeleteSubjectModeFunc func(ctx context.Context, subject string) (string, *net_http.Response, error)

	lockDeleteTag sync.Mutex
	DeleteTagFunc func(ctx context.Context, typeName, qualifiedName, tagName string) (*net_http.Response, error)

	lockDeleteTagDef sync.Mutex
	DeleteTagDefFunc func(ctx context.Context, tagName string) (*net_http.Response, error)

	lockGet sync.Mutex
	GetFunc func(ctx context.Context) (map[string]map[string]interface{}, *net_http.Response, error)

	lockGetAllBusinessMetadataDefs sync.Mutex
	GetAllBusinessMetadataDefsFunc func(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetAllBusinessMetadataDefsOpts) ([]github_com_confluentinc_schema_registry_sdk_go.BusinessMetadataDefResponse, *net_http.Response, error)

	lockGetAllTagDefs sync.Mutex
	GetAllTagDefsFunc func(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetAllTagDefsOpts) ([]github_com_confluentinc_schema_registry_sdk_go.TagDefResponse, *net_http.Response, error)

	lockGetBusinessMetadata sync.Mutex
	GetBusinessMetadataFunc func(ctx context.Context, typeName, qualifiedName string) ([]github_com_confluentinc_schema_registry_sdk_go.BusinessMetadataResponse, *net_http.Response, error)

	lockGetBusinessMetadataDefByName sync.Mutex
	GetBusinessMetadataDefByNameFunc func(ctx context.Context, bmName string) (github_com_confluentinc_schema_registry_sdk_go.AtlasBusinessMetadataDef, *net_http.Response, error)

	lockGetByUniqueAttributes sync.Mutex
	GetByUniqueAttributesFunc func(ctx context.Context, typeName, qualifiedName string, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetByUniqueAttributesOpts) (github_com_confluentinc_schema_registry_sdk_go.AtlasEntityWithExtInfo, *net_http.Response, error)

	lockGetClusterId sync.Mutex
	GetClusterIdFunc func(ctx context.Context) (github_com_confluentinc_schema_registry_sdk_go.ServerClusterId, *net_http.Response, error)

	lockGetExporterConfig sync.Mutex
	GetExporterConfigFunc func(ctx context.Context, name string) (map[string]string, *net_http.Response, error)

	lockGetExporterInfo sync.Mutex
	GetExporterInfoFunc func(ctx context.Context, name string) (github_com_confluentinc_schema_registry_sdk_go.ExporterInfo, *net_http.Response, error)

	lockGetExporterStatus sync.Mutex
	GetExporterStatusFunc func(ctx context.Context, name string) (github_com_confluentinc_schema_registry_sdk_go.ExporterStatus, *net_http.Response, error)

	lockGetExporters sync.Mutex
	GetExportersFunc func(ctx context.Context) ([]string, *net_http.Response, error)

	lockGetMode sync.Mutex
	GetModeFunc func(ctx context.Context, subject string, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetModeOpts) (github_com_confluentinc_schema_registry_sdk_go.Mode, *net_http.Response, error)

	lockGetReferencedBy sync.Mutex
	GetReferencedByFunc func(ctx context.Context, subject, version string) ([]int32, *net_http.Response, error)

	lockGetSchema sync.Mutex
	GetSchemaFunc func(ctx context.Context, id int32, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetSchemaOpts) (github_com_confluentinc_schema_registry_sdk_go.SchemaString, *net_http.Response, error)

	lockGetSchemaByVersion sync.Mutex
	GetSchemaByVersionFunc func(ctx context.Context, subject, version string, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetSchemaByVersionOpts) (github_com_confluentinc_schema_registry_sdk_go.Schema, *net_http.Response, error)

	lockGetSchemaOnly sync.Mutex
	GetSchemaOnlyFunc func(ctx context.Context, subject, version string, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetSchemaOnlyOpts) (string, *net_http.Response, error)

	lockGetSchemaTypes sync.Mutex
	GetSchemaTypesFunc func(ctx context.Context) ([]string, *net_http.Response, error)

	lockGetSchemas sync.Mutex
	GetSchemasFunc func(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetSchemasOpts) ([]github_com_confluentinc_schema_registry_sdk_go.Schema, *net_http.Response, error)

	lockGetSubjectLevelConfig sync.Mutex
	GetSubjectLevelConfigFunc func(ctx context.Context, subject string, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetSubjectLevelConfigOpts) (github_com_confluentinc_schema_registry_sdk_go.Config, *net_http.Response, error)

	lockGetSubjects sync.Mutex
	GetSubjectsFunc func(ctx context.Context, id int32, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetSubjectsOpts) ([]string, *net_http.Response, error)

	lockGetTagDefByName sync.Mutex
	GetTagDefByNameFunc func(ctx context.Context, tagName string) (github_com_confluentinc_schema_registry_sdk_go.TagDef, *net_http.Response, error)

	lockGetTags sync.Mutex
	GetTagsFunc func(ctx context.Context, typeName, qualifiedName string) ([]github_com_confluentinc_schema_registry_sdk_go.TagResponse, *net_http.Response, error)

	lockGetTopLevelConfig sync.Mutex
	GetTopLevelConfigFunc func(ctx context.Context) (github_com_confluentinc_schema_registry_sdk_go.Config, *net_http.Response, error)

	lockGetTopLevelMode sync.Mutex
	GetTopLevelModeFunc func(ctx context.Context) (github_com_confluentinc_schema_registry_sdk_go.Mode, *net_http.Response, error)

	lockGetVersions sync.Mutex
	GetVersionsFunc func(ctx context.Context, id int32, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetVersionsOpts) ([]github_com_confluentinc_schema_registry_sdk_go.SubjectVersion, *net_http.Response, error)

	lockList sync.Mutex
	ListFunc func(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.ListOpts) ([]string, *net_http.Response, error)

	lockListContexts sync.Mutex
	ListContextsFunc func(ctx context.Context) ([]string, *net_http.Response, error)

	lockListVersions sync.Mutex
	ListVersionsFunc func(ctx context.Context, subject string, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.ListVersionsOpts) ([]int32, *net_http.Response, error)

	lockLookUpSchemaUnderSubject sync.Mutex
	LookUpSchemaUnderSubjectFunc func(ctx context.Context, subject string, body github_com_confluentinc_schema_registry_sdk_go.RegisterSchemaRequest, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.LookUpSchemaUnderSubjectOpts) (*net_http.Response, error)

	lockPartialUpdateByUniqueAttributes sync.Mutex
	PartialUpdateByUniqueAttributesFunc func(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.PartialUpdateByUniqueAttributesOpts) (*net_http.Response, error)

	lockPauseExporter sync.Mutex
	PauseExporterFunc func(ctx context.Context, name string) (github_com_confluentinc_schema_registry_sdk_go.UpdateExporterResponse, *net_http.Response, error)

	lockPost sync.Mutex
	PostFunc func(ctx context.Context) (map[string]string, *net_http.Response, error)

	lockPutExporter sync.Mutex
	PutExporterFunc func(ctx context.Context, name string, body github_com_confluentinc_schema_registry_sdk_go.UpdateExporterRequest) (github_com_confluentinc_schema_registry_sdk_go.UpdateExporterResponse, *net_http.Response, error)

	lockPutExporterConfig sync.Mutex
	PutExporterConfigFunc func(ctx context.Context, name string, body map[string]string) (github_com_confluentinc_schema_registry_sdk_go.UpdateExporterResponse, *net_http.Response, error)

	lockRegister sync.Mutex
	RegisterFunc func(ctx context.Context, subject string, body github_com_confluentinc_schema_registry_sdk_go.RegisterSchemaRequest) (github_com_confluentinc_schema_registry_sdk_go.RegisterSchemaResponse, *net_http.Response, error)

	lockResetExporter sync.Mutex
	ResetExporterFunc func(ctx context.Context, name string) (github_com_confluentinc_schema_registry_sdk_go.UpdateExporterResponse, *net_http.Response, error)

	lockResumeExporter sync.Mutex
	ResumeExporterFunc func(ctx context.Context, name string) (github_com_confluentinc_schema_registry_sdk_go.UpdateExporterResponse, *net_http.Response, error)

	lockSearchUsingAttribute sync.Mutex
	SearchUsingAttributeFunc func(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.SearchUsingAttributeOpts) (github_com_confluentinc_schema_registry_sdk_go.SearchResult, *net_http.Response, error)

	lockSearchUsingBasic sync.Mutex
	SearchUsingBasicFunc func(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.SearchUsingBasicOpts) (github_com_confluentinc_schema_registry_sdk_go.SearchResult, *net_http.Response, error)

	lockTestCompatibilityBySubjectName sync.Mutex
	TestCompatibilityBySubjectNameFunc func(ctx context.Context, subject, version string, body github_com_confluentinc_schema_registry_sdk_go.RegisterSchemaRequest, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.TestCompatibilityBySubjectNameOpts) (github_com_confluentinc_schema_registry_sdk_go.CompatibilityCheckResponse, *net_http.Response, error)

	lockTestCompatibilityForSubject sync.Mutex
	TestCompatibilityForSubjectFunc func(ctx context.Context, subject string, body github_com_confluentinc_schema_registry_sdk_go.RegisterSchemaRequest, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.TestCompatibilityForSubjectOpts) (github_com_confluentinc_schema_registry_sdk_go.CompatibilityCheckResponse, *net_http.Response, error)

	lockUpdateBusinessMetadata sync.Mutex
	UpdateBusinessMetadataFunc func(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.UpdateBusinessMetadataOpts) ([]github_com_confluentinc_schema_registry_sdk_go.BusinessMetadataResponse, *net_http.Response, error)

	lockUpdateBusinessMetadataDefs sync.Mutex
	UpdateBusinessMetadataDefsFunc func(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.UpdateBusinessMetadataDefsOpts) ([]github_com_confluentinc_schema_registry_sdk_go.BusinessMetadataDefResponse, *net_http.Response, error)

	lockUpdateMode sync.Mutex
	UpdateModeFunc func(ctx context.Context, subject string, body github_com_confluentinc_schema_registry_sdk_go.ModeUpdateRequest) (github_com_confluentinc_schema_registry_sdk_go.ModeUpdateRequest, *net_http.Response, error)

	lockUpdateSubjectLevelConfig sync.Mutex
	UpdateSubjectLevelConfigFunc func(ctx context.Context, subject string, body github_com_confluentinc_schema_registry_sdk_go.ConfigUpdateRequest) (github_com_confluentinc_schema_registry_sdk_go.ConfigUpdateRequest, *net_http.Response, error)

	lockUpdateTagDefs sync.Mutex
	UpdateTagDefsFunc func(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.UpdateTagDefsOpts) ([]github_com_confluentinc_schema_registry_sdk_go.TagDefResponse, *net_http.Response, error)

	lockUpdateTags sync.Mutex
	UpdateTagsFunc func(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.UpdateTagsOpts) ([]github_com_confluentinc_schema_registry_sdk_go.TagResponse, *net_http.Response, error)

	lockUpdateTopLevelConfig sync.Mutex
	UpdateTopLevelConfigFunc func(ctx context.Context, body github_com_confluentinc_schema_registry_sdk_go.ConfigUpdateRequest) (github_com_confluentinc_schema_registry_sdk_go.ConfigUpdateRequest, *net_http.Response, error)

	lockUpdateTopLevelMode sync.Mutex
	UpdateTopLevelModeFunc func(ctx context.Context, body github_com_confluentinc_schema_registry_sdk_go.ModeUpdateRequest) (github_com_confluentinc_schema_registry_sdk_go.ModeUpdateRequest, *net_http.Response, error)

	calls struct {
		AsyncapiPut []struct {
			Ctx context.Context
		}
		CreateBusinessMetadata []struct {
			Ctx               context.Context
			LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.CreateBusinessMetadataOpts
		}
		CreateBusinessMetadataDefs []struct {
			Ctx               context.Context
			LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.CreateBusinessMetadataDefsOpts
		}
		CreateExporter []struct {
			Ctx  context.Context
			Body github_com_confluentinc_schema_registry_sdk_go.CreateExporterRequest
		}
		CreateOrUpdate []struct {
			Ctx               context.Context
			LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.CreateOrUpdateOpts
		}
		CreateTagDefs []struct {
			Ctx               context.Context
			LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.CreateTagDefsOpts
		}
		CreateTags []struct {
			Ctx               context.Context
			LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.CreateTagsOpts
		}
		DeleteBusinessMetadata []struct {
			Ctx           context.Context
			TypeName      string
			QualifiedName string
			BmName        string
		}
		DeleteBusinessMetadataDef []struct {
			Ctx    context.Context
			BmName string
		}
		DeleteByUniqueAttributes []struct {
			Ctx           context.Context
			TypeName      string
			QualifiedName string
		}
		DeleteExporter []struct {
			Ctx  context.Context
			Name string
		}
		DeleteSchemaVersion []struct {
			Ctx               context.Context
			Subject           string
			Version           string
			LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.DeleteSchemaVersionOpts
		}
		DeleteSubject []struct {
			Ctx               context.Context
			Subject           string
			LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.DeleteSubjectOpts
		}
		DeleteSubjectConfig []struct {
			Ctx     context.Context
			Subject string
		}
		DeleteSubjectMode []struct {
			Ctx     context.Context
			Subject string
		}
		DeleteTag []struct {
			Ctx           context.Context
			TypeName      string
			QualifiedName string
			TagName       string
		}
		DeleteTagDef []struct {
			Ctx     context.Context
			TagName string
		}
		Get []struct {
			Ctx context.Context
		}
		GetAllBusinessMetadataDefs []struct {
			Ctx               context.Context
			LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetAllBusinessMetadataDefsOpts
		}
		GetAllTagDefs []struct {
			Ctx               context.Context
			LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetAllTagDefsOpts
		}
		GetBusinessMetadata []struct {
			Ctx           context.Context
			TypeName      string
			QualifiedName string
		}
		GetBusinessMetadataDefByName []struct {
			Ctx    context.Context
			BmName string
		}
		GetByUniqueAttributes []struct {
			Ctx               context.Context
			TypeName          string
			QualifiedName     string
			LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetByUniqueAttributesOpts
		}
		GetClusterId []struct {
			Ctx context.Context
		}
		GetExporterConfig []struct {
			Ctx  context.Context
			Name string
		}
		GetExporterInfo []struct {
			Ctx  context.Context
			Name string
		}
		GetExporterStatus []struct {
			Ctx  context.Context
			Name string
		}
		GetExporters []struct {
			Ctx context.Context
		}
		GetMode []struct {
			Ctx               context.Context
			Subject           string
			LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetModeOpts
		}
		GetReferencedBy []struct {
			Ctx     context.Context
			Subject string
			Version string
		}
		GetSchema []struct {
			Ctx               context.Context
			Id                int32
			LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetSchemaOpts
		}
		GetSchemaByVersion []struct {
			Ctx               context.Context
			Subject           string
			Version           string
			LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetSchemaByVersionOpts
		}
		GetSchemaOnly []struct {
			Ctx               context.Context
			Subject           string
			Version           string
			LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetSchemaOnlyOpts
		}
		GetSchemaTypes []struct {
			Ctx context.Context
		}
		GetSchemas []struct {
			Ctx               context.Context
			LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetSchemasOpts
		}
		GetSubjectLevelConfig []struct {
			Ctx               context.Context
			Subject           string
			LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetSubjectLevelConfigOpts
		}
		GetSubjects []struct {
			Ctx               context.Context
			Id                int32
			LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetSubjectsOpts
		}
		GetTagDefByName []struct {
			Ctx     context.Context
			TagName string
		}
		GetTags []struct {
			Ctx           context.Context
			TypeName      string
			QualifiedName string
		}
		GetTopLevelConfig []struct {
			Ctx context.Context
		}
		GetTopLevelMode []struct {
			Ctx context.Context
		}
		GetVersions []struct {
			Ctx               context.Context
			Id                int32
			LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetVersionsOpts
		}
		List []struct {
			Ctx               context.Context
			LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.ListOpts
		}
		ListContexts []struct {
			Ctx context.Context
		}
		ListVersions []struct {
			Ctx               context.Context
			Subject           string
			LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.ListVersionsOpts
		}
		LookUpSchemaUnderSubject []struct {
			Ctx               context.Context
			Subject           string
			Body              github_com_confluentinc_schema_registry_sdk_go.RegisterSchemaRequest
			LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.LookUpSchemaUnderSubjectOpts
		}
		PartialUpdateByUniqueAttributes []struct {
			Ctx               context.Context
			LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.PartialUpdateByUniqueAttributesOpts
		}
		PauseExporter []struct {
			Ctx  context.Context
			Name string
		}
		Post []struct {
			Ctx context.Context
		}
		PutExporter []struct {
			Ctx  context.Context
			Name string
			Body github_com_confluentinc_schema_registry_sdk_go.UpdateExporterRequest
		}
		PutExporterConfig []struct {
			Ctx  context.Context
			Name string
			Body map[string]string
		}
		Register []struct {
			Ctx     context.Context
			Subject string
			Body    github_com_confluentinc_schema_registry_sdk_go.RegisterSchemaRequest
		}
		ResetExporter []struct {
			Ctx  context.Context
			Name string
		}
		ResumeExporter []struct {
			Ctx  context.Context
			Name string
		}
		SearchUsingAttribute []struct {
			Ctx               context.Context
			LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.SearchUsingAttributeOpts
		}
		SearchUsingBasic []struct {
			Ctx               context.Context
			LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.SearchUsingBasicOpts
		}
		TestCompatibilityBySubjectName []struct {
			Ctx               context.Context
			Subject           string
			Version           string
			Body              github_com_confluentinc_schema_registry_sdk_go.RegisterSchemaRequest
			LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.TestCompatibilityBySubjectNameOpts
		}
		TestCompatibilityForSubject []struct {
			Ctx               context.Context
			Subject           string
			Body              github_com_confluentinc_schema_registry_sdk_go.RegisterSchemaRequest
			LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.TestCompatibilityForSubjectOpts
		}
		UpdateBusinessMetadata []struct {
			Ctx               context.Context
			LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.UpdateBusinessMetadataOpts
		}
		UpdateBusinessMetadataDefs []struct {
			Ctx               context.Context
			LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.UpdateBusinessMetadataDefsOpts
		}
		UpdateMode []struct {
			Ctx     context.Context
			Subject string
			Body    github_com_confluentinc_schema_registry_sdk_go.ModeUpdateRequest
		}
		UpdateSubjectLevelConfig []struct {
			Ctx     context.Context
			Subject string
			Body    github_com_confluentinc_schema_registry_sdk_go.ConfigUpdateRequest
		}
		UpdateTagDefs []struct {
			Ctx               context.Context
			LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.UpdateTagDefsOpts
		}
		UpdateTags []struct {
			Ctx               context.Context
			LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.UpdateTagsOpts
		}
		UpdateTopLevelConfig []struct {
			Ctx  context.Context
			Body github_com_confluentinc_schema_registry_sdk_go.ConfigUpdateRequest
		}
		UpdateTopLevelMode []struct {
			Ctx  context.Context
			Body github_com_confluentinc_schema_registry_sdk_go.ModeUpdateRequest
		}
	}
}

// AsyncapiPut mocks base method by wrapping the associated func.
func (m *DefaultApi) AsyncapiPut(ctx context.Context) (*net_http.Response, error) {
	m.lockAsyncapiPut.Lock()
	defer m.lockAsyncapiPut.Unlock()

	if m.AsyncapiPutFunc == nil {
		panic("mocker: DefaultApi.AsyncapiPutFunc is nil but DefaultApi.AsyncapiPut was called.")
	}

	call := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}

	m.calls.AsyncapiPut = append(m.calls.AsyncapiPut, call)

	return m.AsyncapiPutFunc(ctx)
}

// AsyncapiPutCalled returns true if AsyncapiPut was called at least once.
func (m *DefaultApi) AsyncapiPutCalled() bool {
	m.lockAsyncapiPut.Lock()
	defer m.lockAsyncapiPut.Unlock()

	return len(m.calls.AsyncapiPut) > 0
}

// AsyncapiPutCalls returns the calls made to AsyncapiPut.
func (m *DefaultApi) AsyncapiPutCalls() []struct {
	Ctx context.Context
} {
	m.lockAsyncapiPut.Lock()
	defer m.lockAsyncapiPut.Unlock()

	return m.calls.AsyncapiPut
}

// CreateBusinessMetadata mocks base method by wrapping the associated func.
func (m *DefaultApi) CreateBusinessMetadata(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.CreateBusinessMetadataOpts) ([]github_com_confluentinc_schema_registry_sdk_go.BusinessMetadataResponse, *net_http.Response, error) {
	m.lockCreateBusinessMetadata.Lock()
	defer m.lockCreateBusinessMetadata.Unlock()

	if m.CreateBusinessMetadataFunc == nil {
		panic("mocker: DefaultApi.CreateBusinessMetadataFunc is nil but DefaultApi.CreateBusinessMetadata was called.")
	}

	call := struct {
		Ctx               context.Context
		LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.CreateBusinessMetadataOpts
	}{
		Ctx:               ctx,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.CreateBusinessMetadata = append(m.calls.CreateBusinessMetadata, call)

	return m.CreateBusinessMetadataFunc(ctx, localVarOptionals)
}

// CreateBusinessMetadataCalled returns true if CreateBusinessMetadata was called at least once.
func (m *DefaultApi) CreateBusinessMetadataCalled() bool {
	m.lockCreateBusinessMetadata.Lock()
	defer m.lockCreateBusinessMetadata.Unlock()

	return len(m.calls.CreateBusinessMetadata) > 0
}

// CreateBusinessMetadataCalls returns the calls made to CreateBusinessMetadata.
func (m *DefaultApi) CreateBusinessMetadataCalls() []struct {
	Ctx               context.Context
	LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.CreateBusinessMetadataOpts
} {
	m.lockCreateBusinessMetadata.Lock()
	defer m.lockCreateBusinessMetadata.Unlock()

	return m.calls.CreateBusinessMetadata
}

// CreateBusinessMetadataDefs mocks base method by wrapping the associated func.
func (m *DefaultApi) CreateBusinessMetadataDefs(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.CreateBusinessMetadataDefsOpts) ([]github_com_confluentinc_schema_registry_sdk_go.BusinessMetadataDefResponse, *net_http.Response, error) {
	m.lockCreateBusinessMetadataDefs.Lock()
	defer m.lockCreateBusinessMetadataDefs.Unlock()

	if m.CreateBusinessMetadataDefsFunc == nil {
		panic("mocker: DefaultApi.CreateBusinessMetadataDefsFunc is nil but DefaultApi.CreateBusinessMetadataDefs was called.")
	}

	call := struct {
		Ctx               context.Context
		LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.CreateBusinessMetadataDefsOpts
	}{
		Ctx:               ctx,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.CreateBusinessMetadataDefs = append(m.calls.CreateBusinessMetadataDefs, call)

	return m.CreateBusinessMetadataDefsFunc(ctx, localVarOptionals)
}

// CreateBusinessMetadataDefsCalled returns true if CreateBusinessMetadataDefs was called at least once.
func (m *DefaultApi) CreateBusinessMetadataDefsCalled() bool {
	m.lockCreateBusinessMetadataDefs.Lock()
	defer m.lockCreateBusinessMetadataDefs.Unlock()

	return len(m.calls.CreateBusinessMetadataDefs) > 0
}

// CreateBusinessMetadataDefsCalls returns the calls made to CreateBusinessMetadataDefs.
func (m *DefaultApi) CreateBusinessMetadataDefsCalls() []struct {
	Ctx               context.Context
	LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.CreateBusinessMetadataDefsOpts
} {
	m.lockCreateBusinessMetadataDefs.Lock()
	defer m.lockCreateBusinessMetadataDefs.Unlock()

	return m.calls.CreateBusinessMetadataDefs
}

// CreateExporter mocks base method by wrapping the associated func.
func (m *DefaultApi) CreateExporter(ctx context.Context, body github_com_confluentinc_schema_registry_sdk_go.CreateExporterRequest) (github_com_confluentinc_schema_registry_sdk_go.CreateExporterResponse, *net_http.Response, error) {
	m.lockCreateExporter.Lock()
	defer m.lockCreateExporter.Unlock()

	if m.CreateExporterFunc == nil {
		panic("mocker: DefaultApi.CreateExporterFunc is nil but DefaultApi.CreateExporter was called.")
	}

	call := struct {
		Ctx  context.Context
		Body github_com_confluentinc_schema_registry_sdk_go.CreateExporterRequest
	}{
		Ctx:  ctx,
		Body: body,
	}

	m.calls.CreateExporter = append(m.calls.CreateExporter, call)

	return m.CreateExporterFunc(ctx, body)
}

// CreateExporterCalled returns true if CreateExporter was called at least once.
func (m *DefaultApi) CreateExporterCalled() bool {
	m.lockCreateExporter.Lock()
	defer m.lockCreateExporter.Unlock()

	return len(m.calls.CreateExporter) > 0
}

// CreateExporterCalls returns the calls made to CreateExporter.
func (m *DefaultApi) CreateExporterCalls() []struct {
	Ctx  context.Context
	Body github_com_confluentinc_schema_registry_sdk_go.CreateExporterRequest
} {
	m.lockCreateExporter.Lock()
	defer m.lockCreateExporter.Unlock()

	return m.calls.CreateExporter
}

// CreateOrUpdate mocks base method by wrapping the associated func.
func (m *DefaultApi) CreateOrUpdate(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.CreateOrUpdateOpts) (*net_http.Response, error) {
	m.lockCreateOrUpdate.Lock()
	defer m.lockCreateOrUpdate.Unlock()

	if m.CreateOrUpdateFunc == nil {
		panic("mocker: DefaultApi.CreateOrUpdateFunc is nil but DefaultApi.CreateOrUpdate was called.")
	}

	call := struct {
		Ctx               context.Context
		LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.CreateOrUpdateOpts
	}{
		Ctx:               ctx,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.CreateOrUpdate = append(m.calls.CreateOrUpdate, call)

	return m.CreateOrUpdateFunc(ctx, localVarOptionals)
}

// CreateOrUpdateCalled returns true if CreateOrUpdate was called at least once.
func (m *DefaultApi) CreateOrUpdateCalled() bool {
	m.lockCreateOrUpdate.Lock()
	defer m.lockCreateOrUpdate.Unlock()

	return len(m.calls.CreateOrUpdate) > 0
}

// CreateOrUpdateCalls returns the calls made to CreateOrUpdate.
func (m *DefaultApi) CreateOrUpdateCalls() []struct {
	Ctx               context.Context
	LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.CreateOrUpdateOpts
} {
	m.lockCreateOrUpdate.Lock()
	defer m.lockCreateOrUpdate.Unlock()

	return m.calls.CreateOrUpdate
}

// CreateTagDefs mocks base method by wrapping the associated func.
func (m *DefaultApi) CreateTagDefs(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.CreateTagDefsOpts) ([]github_com_confluentinc_schema_registry_sdk_go.TagDefResponse, *net_http.Response, error) {
	m.lockCreateTagDefs.Lock()
	defer m.lockCreateTagDefs.Unlock()

	if m.CreateTagDefsFunc == nil {
		panic("mocker: DefaultApi.CreateTagDefsFunc is nil but DefaultApi.CreateTagDefs was called.")
	}

	call := struct {
		Ctx               context.Context
		LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.CreateTagDefsOpts
	}{
		Ctx:               ctx,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.CreateTagDefs = append(m.calls.CreateTagDefs, call)

	return m.CreateTagDefsFunc(ctx, localVarOptionals)
}

// CreateTagDefsCalled returns true if CreateTagDefs was called at least once.
func (m *DefaultApi) CreateTagDefsCalled() bool {
	m.lockCreateTagDefs.Lock()
	defer m.lockCreateTagDefs.Unlock()

	return len(m.calls.CreateTagDefs) > 0
}

// CreateTagDefsCalls returns the calls made to CreateTagDefs.
func (m *DefaultApi) CreateTagDefsCalls() []struct {
	Ctx               context.Context
	LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.CreateTagDefsOpts
} {
	m.lockCreateTagDefs.Lock()
	defer m.lockCreateTagDefs.Unlock()

	return m.calls.CreateTagDefs
}

// CreateTags mocks base method by wrapping the associated func.
func (m *DefaultApi) CreateTags(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.CreateTagsOpts) ([]github_com_confluentinc_schema_registry_sdk_go.TagResponse, *net_http.Response, error) {
	m.lockCreateTags.Lock()
	defer m.lockCreateTags.Unlock()

	if m.CreateTagsFunc == nil {
		panic("mocker: DefaultApi.CreateTagsFunc is nil but DefaultApi.CreateTags was called.")
	}

	call := struct {
		Ctx               context.Context
		LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.CreateTagsOpts
	}{
		Ctx:               ctx,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.CreateTags = append(m.calls.CreateTags, call)

	return m.CreateTagsFunc(ctx, localVarOptionals)
}

// CreateTagsCalled returns true if CreateTags was called at least once.
func (m *DefaultApi) CreateTagsCalled() bool {
	m.lockCreateTags.Lock()
	defer m.lockCreateTags.Unlock()

	return len(m.calls.CreateTags) > 0
}

// CreateTagsCalls returns the calls made to CreateTags.
func (m *DefaultApi) CreateTagsCalls() []struct {
	Ctx               context.Context
	LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.CreateTagsOpts
} {
	m.lockCreateTags.Lock()
	defer m.lockCreateTags.Unlock()

	return m.calls.CreateTags
}

// DeleteBusinessMetadata mocks base method by wrapping the associated func.
func (m *DefaultApi) DeleteBusinessMetadata(ctx context.Context, typeName, qualifiedName, bmName string) (*net_http.Response, error) {
	m.lockDeleteBusinessMetadata.Lock()
	defer m.lockDeleteBusinessMetadata.Unlock()

	if m.DeleteBusinessMetadataFunc == nil {
		panic("mocker: DefaultApi.DeleteBusinessMetadataFunc is nil but DefaultApi.DeleteBusinessMetadata was called.")
	}

	call := struct {
		Ctx           context.Context
		TypeName      string
		QualifiedName string
		BmName        string
	}{
		Ctx:           ctx,
		TypeName:      typeName,
		QualifiedName: qualifiedName,
		BmName:        bmName,
	}

	m.calls.DeleteBusinessMetadata = append(m.calls.DeleteBusinessMetadata, call)

	return m.DeleteBusinessMetadataFunc(ctx, typeName, qualifiedName, bmName)
}

// DeleteBusinessMetadataCalled returns true if DeleteBusinessMetadata was called at least once.
func (m *DefaultApi) DeleteBusinessMetadataCalled() bool {
	m.lockDeleteBusinessMetadata.Lock()
	defer m.lockDeleteBusinessMetadata.Unlock()

	return len(m.calls.DeleteBusinessMetadata) > 0
}

// DeleteBusinessMetadataCalls returns the calls made to DeleteBusinessMetadata.
func (m *DefaultApi) DeleteBusinessMetadataCalls() []struct {
	Ctx           context.Context
	TypeName      string
	QualifiedName string
	BmName        string
} {
	m.lockDeleteBusinessMetadata.Lock()
	defer m.lockDeleteBusinessMetadata.Unlock()

	return m.calls.DeleteBusinessMetadata
}

// DeleteBusinessMetadataDef mocks base method by wrapping the associated func.
func (m *DefaultApi) DeleteBusinessMetadataDef(ctx context.Context, bmName string) (*net_http.Response, error) {
	m.lockDeleteBusinessMetadataDef.Lock()
	defer m.lockDeleteBusinessMetadataDef.Unlock()

	if m.DeleteBusinessMetadataDefFunc == nil {
		panic("mocker: DefaultApi.DeleteBusinessMetadataDefFunc is nil but DefaultApi.DeleteBusinessMetadataDef was called.")
	}

	call := struct {
		Ctx    context.Context
		BmName string
	}{
		Ctx:    ctx,
		BmName: bmName,
	}

	m.calls.DeleteBusinessMetadataDef = append(m.calls.DeleteBusinessMetadataDef, call)

	return m.DeleteBusinessMetadataDefFunc(ctx, bmName)
}

// DeleteBusinessMetadataDefCalled returns true if DeleteBusinessMetadataDef was called at least once.
func (m *DefaultApi) DeleteBusinessMetadataDefCalled() bool {
	m.lockDeleteBusinessMetadataDef.Lock()
	defer m.lockDeleteBusinessMetadataDef.Unlock()

	return len(m.calls.DeleteBusinessMetadataDef) > 0
}

// DeleteBusinessMetadataDefCalls returns the calls made to DeleteBusinessMetadataDef.
func (m *DefaultApi) DeleteBusinessMetadataDefCalls() []struct {
	Ctx    context.Context
	BmName string
} {
	m.lockDeleteBusinessMetadataDef.Lock()
	defer m.lockDeleteBusinessMetadataDef.Unlock()

	return m.calls.DeleteBusinessMetadataDef
}

// DeleteByUniqueAttributes mocks base method by wrapping the associated func.
func (m *DefaultApi) DeleteByUniqueAttributes(ctx context.Context, typeName, qualifiedName string) (*net_http.Response, error) {
	m.lockDeleteByUniqueAttributes.Lock()
	defer m.lockDeleteByUniqueAttributes.Unlock()

	if m.DeleteByUniqueAttributesFunc == nil {
		panic("mocker: DefaultApi.DeleteByUniqueAttributesFunc is nil but DefaultApi.DeleteByUniqueAttributes was called.")
	}

	call := struct {
		Ctx           context.Context
		TypeName      string
		QualifiedName string
	}{
		Ctx:           ctx,
		TypeName:      typeName,
		QualifiedName: qualifiedName,
	}

	m.calls.DeleteByUniqueAttributes = append(m.calls.DeleteByUniqueAttributes, call)

	return m.DeleteByUniqueAttributesFunc(ctx, typeName, qualifiedName)
}

// DeleteByUniqueAttributesCalled returns true if DeleteByUniqueAttributes was called at least once.
func (m *DefaultApi) DeleteByUniqueAttributesCalled() bool {
	m.lockDeleteByUniqueAttributes.Lock()
	defer m.lockDeleteByUniqueAttributes.Unlock()

	return len(m.calls.DeleteByUniqueAttributes) > 0
}

// DeleteByUniqueAttributesCalls returns the calls made to DeleteByUniqueAttributes.
func (m *DefaultApi) DeleteByUniqueAttributesCalls() []struct {
	Ctx           context.Context
	TypeName      string
	QualifiedName string
} {
	m.lockDeleteByUniqueAttributes.Lock()
	defer m.lockDeleteByUniqueAttributes.Unlock()

	return m.calls.DeleteByUniqueAttributes
}

// DeleteExporter mocks base method by wrapping the associated func.
func (m *DefaultApi) DeleteExporter(ctx context.Context, name string) (*net_http.Response, error) {
	m.lockDeleteExporter.Lock()
	defer m.lockDeleteExporter.Unlock()

	if m.DeleteExporterFunc == nil {
		panic("mocker: DefaultApi.DeleteExporterFunc is nil but DefaultApi.DeleteExporter was called.")
	}

	call := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}

	m.calls.DeleteExporter = append(m.calls.DeleteExporter, call)

	return m.DeleteExporterFunc(ctx, name)
}

// DeleteExporterCalled returns true if DeleteExporter was called at least once.
func (m *DefaultApi) DeleteExporterCalled() bool {
	m.lockDeleteExporter.Lock()
	defer m.lockDeleteExporter.Unlock()

	return len(m.calls.DeleteExporter) > 0
}

// DeleteExporterCalls returns the calls made to DeleteExporter.
func (m *DefaultApi) DeleteExporterCalls() []struct {
	Ctx  context.Context
	Name string
} {
	m.lockDeleteExporter.Lock()
	defer m.lockDeleteExporter.Unlock()

	return m.calls.DeleteExporter
}

// DeleteSchemaVersion mocks base method by wrapping the associated func.
func (m *DefaultApi) DeleteSchemaVersion(ctx context.Context, subject, version string, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.DeleteSchemaVersionOpts) (int32, *net_http.Response, error) {
	m.lockDeleteSchemaVersion.Lock()
	defer m.lockDeleteSchemaVersion.Unlock()

	if m.DeleteSchemaVersionFunc == nil {
		panic("mocker: DefaultApi.DeleteSchemaVersionFunc is nil but DefaultApi.DeleteSchemaVersion was called.")
	}

	call := struct {
		Ctx               context.Context
		Subject           string
		Version           string
		LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.DeleteSchemaVersionOpts
	}{
		Ctx:               ctx,
		Subject:           subject,
		Version:           version,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.DeleteSchemaVersion = append(m.calls.DeleteSchemaVersion, call)

	return m.DeleteSchemaVersionFunc(ctx, subject, version, localVarOptionals)
}

// DeleteSchemaVersionCalled returns true if DeleteSchemaVersion was called at least once.
func (m *DefaultApi) DeleteSchemaVersionCalled() bool {
	m.lockDeleteSchemaVersion.Lock()
	defer m.lockDeleteSchemaVersion.Unlock()

	return len(m.calls.DeleteSchemaVersion) > 0
}

// DeleteSchemaVersionCalls returns the calls made to DeleteSchemaVersion.
func (m *DefaultApi) DeleteSchemaVersionCalls() []struct {
	Ctx               context.Context
	Subject           string
	Version           string
	LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.DeleteSchemaVersionOpts
} {
	m.lockDeleteSchemaVersion.Lock()
	defer m.lockDeleteSchemaVersion.Unlock()

	return m.calls.DeleteSchemaVersion
}

// DeleteSubject mocks base method by wrapping the associated func.
func (m *DefaultApi) DeleteSubject(ctx context.Context, subject string, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.DeleteSubjectOpts) ([]int32, *net_http.Response, error) {
	m.lockDeleteSubject.Lock()
	defer m.lockDeleteSubject.Unlock()

	if m.DeleteSubjectFunc == nil {
		panic("mocker: DefaultApi.DeleteSubjectFunc is nil but DefaultApi.DeleteSubject was called.")
	}

	call := struct {
		Ctx               context.Context
		Subject           string
		LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.DeleteSubjectOpts
	}{
		Ctx:               ctx,
		Subject:           subject,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.DeleteSubject = append(m.calls.DeleteSubject, call)

	return m.DeleteSubjectFunc(ctx, subject, localVarOptionals)
}

// DeleteSubjectCalled returns true if DeleteSubject was called at least once.
func (m *DefaultApi) DeleteSubjectCalled() bool {
	m.lockDeleteSubject.Lock()
	defer m.lockDeleteSubject.Unlock()

	return len(m.calls.DeleteSubject) > 0
}

// DeleteSubjectCalls returns the calls made to DeleteSubject.
func (m *DefaultApi) DeleteSubjectCalls() []struct {
	Ctx               context.Context
	Subject           string
	LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.DeleteSubjectOpts
} {
	m.lockDeleteSubject.Lock()
	defer m.lockDeleteSubject.Unlock()

	return m.calls.DeleteSubject
}

// DeleteSubjectConfig mocks base method by wrapping the associated func.
func (m *DefaultApi) DeleteSubjectConfig(ctx context.Context, subject string) (string, *net_http.Response, error) {
	m.lockDeleteSubjectConfig.Lock()
	defer m.lockDeleteSubjectConfig.Unlock()

	if m.DeleteSubjectConfigFunc == nil {
		panic("mocker: DefaultApi.DeleteSubjectConfigFunc is nil but DefaultApi.DeleteSubjectConfig was called.")
	}

	call := struct {
		Ctx     context.Context
		Subject string
	}{
		Ctx:     ctx,
		Subject: subject,
	}

	m.calls.DeleteSubjectConfig = append(m.calls.DeleteSubjectConfig, call)

	return m.DeleteSubjectConfigFunc(ctx, subject)
}

// DeleteSubjectConfigCalled returns true if DeleteSubjectConfig was called at least once.
func (m *DefaultApi) DeleteSubjectConfigCalled() bool {
	m.lockDeleteSubjectConfig.Lock()
	defer m.lockDeleteSubjectConfig.Unlock()

	return len(m.calls.DeleteSubjectConfig) > 0
}

// DeleteSubjectConfigCalls returns the calls made to DeleteSubjectConfig.
func (m *DefaultApi) DeleteSubjectConfigCalls() []struct {
	Ctx     context.Context
	Subject string
} {
	m.lockDeleteSubjectConfig.Lock()
	defer m.lockDeleteSubjectConfig.Unlock()

	return m.calls.DeleteSubjectConfig
}

// DeleteSubjectMode mocks base method by wrapping the associated func.
func (m *DefaultApi) DeleteSubjectMode(ctx context.Context, subject string) (string, *net_http.Response, error) {
	m.lockDeleteSubjectMode.Lock()
	defer m.lockDeleteSubjectMode.Unlock()

	if m.DeleteSubjectModeFunc == nil {
		panic("mocker: DefaultApi.DeleteSubjectModeFunc is nil but DefaultApi.DeleteSubjectMode was called.")
	}

	call := struct {
		Ctx     context.Context
		Subject string
	}{
		Ctx:     ctx,
		Subject: subject,
	}

	m.calls.DeleteSubjectMode = append(m.calls.DeleteSubjectMode, call)

	return m.DeleteSubjectModeFunc(ctx, subject)
}

// DeleteSubjectModeCalled returns true if DeleteSubjectMode was called at least once.
func (m *DefaultApi) DeleteSubjectModeCalled() bool {
	m.lockDeleteSubjectMode.Lock()
	defer m.lockDeleteSubjectMode.Unlock()

	return len(m.calls.DeleteSubjectMode) > 0
}

// DeleteSubjectModeCalls returns the calls made to DeleteSubjectMode.
func (m *DefaultApi) DeleteSubjectModeCalls() []struct {
	Ctx     context.Context
	Subject string
} {
	m.lockDeleteSubjectMode.Lock()
	defer m.lockDeleteSubjectMode.Unlock()

	return m.calls.DeleteSubjectMode
}

// DeleteTag mocks base method by wrapping the associated func.
func (m *DefaultApi) DeleteTag(ctx context.Context, typeName, qualifiedName, tagName string) (*net_http.Response, error) {
	m.lockDeleteTag.Lock()
	defer m.lockDeleteTag.Unlock()

	if m.DeleteTagFunc == nil {
		panic("mocker: DefaultApi.DeleteTagFunc is nil but DefaultApi.DeleteTag was called.")
	}

	call := struct {
		Ctx           context.Context
		TypeName      string
		QualifiedName string
		TagName       string
	}{
		Ctx:           ctx,
		TypeName:      typeName,
		QualifiedName: qualifiedName,
		TagName:       tagName,
	}

	m.calls.DeleteTag = append(m.calls.DeleteTag, call)

	return m.DeleteTagFunc(ctx, typeName, qualifiedName, tagName)
}

// DeleteTagCalled returns true if DeleteTag was called at least once.
func (m *DefaultApi) DeleteTagCalled() bool {
	m.lockDeleteTag.Lock()
	defer m.lockDeleteTag.Unlock()

	return len(m.calls.DeleteTag) > 0
}

// DeleteTagCalls returns the calls made to DeleteTag.
func (m *DefaultApi) DeleteTagCalls() []struct {
	Ctx           context.Context
	TypeName      string
	QualifiedName string
	TagName       string
} {
	m.lockDeleteTag.Lock()
	defer m.lockDeleteTag.Unlock()

	return m.calls.DeleteTag
}

// DeleteTagDef mocks base method by wrapping the associated func.
func (m *DefaultApi) DeleteTagDef(ctx context.Context, tagName string) (*net_http.Response, error) {
	m.lockDeleteTagDef.Lock()
	defer m.lockDeleteTagDef.Unlock()

	if m.DeleteTagDefFunc == nil {
		panic("mocker: DefaultApi.DeleteTagDefFunc is nil but DefaultApi.DeleteTagDef was called.")
	}

	call := struct {
		Ctx     context.Context
		TagName string
	}{
		Ctx:     ctx,
		TagName: tagName,
	}

	m.calls.DeleteTagDef = append(m.calls.DeleteTagDef, call)

	return m.DeleteTagDefFunc(ctx, tagName)
}

// DeleteTagDefCalled returns true if DeleteTagDef was called at least once.
func (m *DefaultApi) DeleteTagDefCalled() bool {
	m.lockDeleteTagDef.Lock()
	defer m.lockDeleteTagDef.Unlock()

	return len(m.calls.DeleteTagDef) > 0
}

// DeleteTagDefCalls returns the calls made to DeleteTagDef.
func (m *DefaultApi) DeleteTagDefCalls() []struct {
	Ctx     context.Context
	TagName string
} {
	m.lockDeleteTagDef.Lock()
	defer m.lockDeleteTagDef.Unlock()

	return m.calls.DeleteTagDef
}

// Get mocks base method by wrapping the associated func.
func (m *DefaultApi) Get(ctx context.Context) (map[string]map[string]interface{}, *net_http.Response, error) {
	m.lockGet.Lock()
	defer m.lockGet.Unlock()

	if m.GetFunc == nil {
		panic("mocker: DefaultApi.GetFunc is nil but DefaultApi.Get was called.")
	}

	call := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}

	m.calls.Get = append(m.calls.Get, call)

	return m.GetFunc(ctx)
}

// GetCalled returns true if Get was called at least once.
func (m *DefaultApi) GetCalled() bool {
	m.lockGet.Lock()
	defer m.lockGet.Unlock()

	return len(m.calls.Get) > 0
}

// GetCalls returns the calls made to Get.
func (m *DefaultApi) GetCalls() []struct {
	Ctx context.Context
} {
	m.lockGet.Lock()
	defer m.lockGet.Unlock()

	return m.calls.Get
}

// GetAllBusinessMetadataDefs mocks base method by wrapping the associated func.
func (m *DefaultApi) GetAllBusinessMetadataDefs(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetAllBusinessMetadataDefsOpts) ([]github_com_confluentinc_schema_registry_sdk_go.BusinessMetadataDefResponse, *net_http.Response, error) {
	m.lockGetAllBusinessMetadataDefs.Lock()
	defer m.lockGetAllBusinessMetadataDefs.Unlock()

	if m.GetAllBusinessMetadataDefsFunc == nil {
		panic("mocker: DefaultApi.GetAllBusinessMetadataDefsFunc is nil but DefaultApi.GetAllBusinessMetadataDefs was called.")
	}

	call := struct {
		Ctx               context.Context
		LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetAllBusinessMetadataDefsOpts
	}{
		Ctx:               ctx,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.GetAllBusinessMetadataDefs = append(m.calls.GetAllBusinessMetadataDefs, call)

	return m.GetAllBusinessMetadataDefsFunc(ctx, localVarOptionals)
}

// GetAllBusinessMetadataDefsCalled returns true if GetAllBusinessMetadataDefs was called at least once.
func (m *DefaultApi) GetAllBusinessMetadataDefsCalled() bool {
	m.lockGetAllBusinessMetadataDefs.Lock()
	defer m.lockGetAllBusinessMetadataDefs.Unlock()

	return len(m.calls.GetAllBusinessMetadataDefs) > 0
}

// GetAllBusinessMetadataDefsCalls returns the calls made to GetAllBusinessMetadataDefs.
func (m *DefaultApi) GetAllBusinessMetadataDefsCalls() []struct {
	Ctx               context.Context
	LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetAllBusinessMetadataDefsOpts
} {
	m.lockGetAllBusinessMetadataDefs.Lock()
	defer m.lockGetAllBusinessMetadataDefs.Unlock()

	return m.calls.GetAllBusinessMetadataDefs
}

// GetAllTagDefs mocks base method by wrapping the associated func.
func (m *DefaultApi) GetAllTagDefs(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetAllTagDefsOpts) ([]github_com_confluentinc_schema_registry_sdk_go.TagDefResponse, *net_http.Response, error) {
	m.lockGetAllTagDefs.Lock()
	defer m.lockGetAllTagDefs.Unlock()

	if m.GetAllTagDefsFunc == nil {
		panic("mocker: DefaultApi.GetAllTagDefsFunc is nil but DefaultApi.GetAllTagDefs was called.")
	}

	call := struct {
		Ctx               context.Context
		LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetAllTagDefsOpts
	}{
		Ctx:               ctx,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.GetAllTagDefs = append(m.calls.GetAllTagDefs, call)

	return m.GetAllTagDefsFunc(ctx, localVarOptionals)
}

// GetAllTagDefsCalled returns true if GetAllTagDefs was called at least once.
func (m *DefaultApi) GetAllTagDefsCalled() bool {
	m.lockGetAllTagDefs.Lock()
	defer m.lockGetAllTagDefs.Unlock()

	return len(m.calls.GetAllTagDefs) > 0
}

// GetAllTagDefsCalls returns the calls made to GetAllTagDefs.
func (m *DefaultApi) GetAllTagDefsCalls() []struct {
	Ctx               context.Context
	LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetAllTagDefsOpts
} {
	m.lockGetAllTagDefs.Lock()
	defer m.lockGetAllTagDefs.Unlock()

	return m.calls.GetAllTagDefs
}

// GetBusinessMetadata mocks base method by wrapping the associated func.
func (m *DefaultApi) GetBusinessMetadata(ctx context.Context, typeName, qualifiedName string) ([]github_com_confluentinc_schema_registry_sdk_go.BusinessMetadataResponse, *net_http.Response, error) {
	m.lockGetBusinessMetadata.Lock()
	defer m.lockGetBusinessMetadata.Unlock()

	if m.GetBusinessMetadataFunc == nil {
		panic("mocker: DefaultApi.GetBusinessMetadataFunc is nil but DefaultApi.GetBusinessMetadata was called.")
	}

	call := struct {
		Ctx           context.Context
		TypeName      string
		QualifiedName string
	}{
		Ctx:           ctx,
		TypeName:      typeName,
		QualifiedName: qualifiedName,
	}

	m.calls.GetBusinessMetadata = append(m.calls.GetBusinessMetadata, call)

	return m.GetBusinessMetadataFunc(ctx, typeName, qualifiedName)
}

// GetBusinessMetadataCalled returns true if GetBusinessMetadata was called at least once.
func (m *DefaultApi) GetBusinessMetadataCalled() bool {
	m.lockGetBusinessMetadata.Lock()
	defer m.lockGetBusinessMetadata.Unlock()

	return len(m.calls.GetBusinessMetadata) > 0
}

// GetBusinessMetadataCalls returns the calls made to GetBusinessMetadata.
func (m *DefaultApi) GetBusinessMetadataCalls() []struct {
	Ctx           context.Context
	TypeName      string
	QualifiedName string
} {
	m.lockGetBusinessMetadata.Lock()
	defer m.lockGetBusinessMetadata.Unlock()

	return m.calls.GetBusinessMetadata
}

// GetBusinessMetadataDefByName mocks base method by wrapping the associated func.
func (m *DefaultApi) GetBusinessMetadataDefByName(ctx context.Context, bmName string) (github_com_confluentinc_schema_registry_sdk_go.AtlasBusinessMetadataDef, *net_http.Response, error) {
	m.lockGetBusinessMetadataDefByName.Lock()
	defer m.lockGetBusinessMetadataDefByName.Unlock()

	if m.GetBusinessMetadataDefByNameFunc == nil {
		panic("mocker: DefaultApi.GetBusinessMetadataDefByNameFunc is nil but DefaultApi.GetBusinessMetadataDefByName was called.")
	}

	call := struct {
		Ctx    context.Context
		BmName string
	}{
		Ctx:    ctx,
		BmName: bmName,
	}

	m.calls.GetBusinessMetadataDefByName = append(m.calls.GetBusinessMetadataDefByName, call)

	return m.GetBusinessMetadataDefByNameFunc(ctx, bmName)
}

// GetBusinessMetadataDefByNameCalled returns true if GetBusinessMetadataDefByName was called at least once.
func (m *DefaultApi) GetBusinessMetadataDefByNameCalled() bool {
	m.lockGetBusinessMetadataDefByName.Lock()
	defer m.lockGetBusinessMetadataDefByName.Unlock()

	return len(m.calls.GetBusinessMetadataDefByName) > 0
}

// GetBusinessMetadataDefByNameCalls returns the calls made to GetBusinessMetadataDefByName.
func (m *DefaultApi) GetBusinessMetadataDefByNameCalls() []struct {
	Ctx    context.Context
	BmName string
} {
	m.lockGetBusinessMetadataDefByName.Lock()
	defer m.lockGetBusinessMetadataDefByName.Unlock()

	return m.calls.GetBusinessMetadataDefByName
}

// GetByUniqueAttributes mocks base method by wrapping the associated func.
func (m *DefaultApi) GetByUniqueAttributes(ctx context.Context, typeName, qualifiedName string, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetByUniqueAttributesOpts) (github_com_confluentinc_schema_registry_sdk_go.AtlasEntityWithExtInfo, *net_http.Response, error) {
	m.lockGetByUniqueAttributes.Lock()
	defer m.lockGetByUniqueAttributes.Unlock()

	if m.GetByUniqueAttributesFunc == nil {
		panic("mocker: DefaultApi.GetByUniqueAttributesFunc is nil but DefaultApi.GetByUniqueAttributes was called.")
	}

	call := struct {
		Ctx               context.Context
		TypeName          string
		QualifiedName     string
		LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetByUniqueAttributesOpts
	}{
		Ctx:               ctx,
		TypeName:          typeName,
		QualifiedName:     qualifiedName,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.GetByUniqueAttributes = append(m.calls.GetByUniqueAttributes, call)

	return m.GetByUniqueAttributesFunc(ctx, typeName, qualifiedName, localVarOptionals)
}

// GetByUniqueAttributesCalled returns true if GetByUniqueAttributes was called at least once.
func (m *DefaultApi) GetByUniqueAttributesCalled() bool {
	m.lockGetByUniqueAttributes.Lock()
	defer m.lockGetByUniqueAttributes.Unlock()

	return len(m.calls.GetByUniqueAttributes) > 0
}

// GetByUniqueAttributesCalls returns the calls made to GetByUniqueAttributes.
func (m *DefaultApi) GetByUniqueAttributesCalls() []struct {
	Ctx               context.Context
	TypeName          string
	QualifiedName     string
	LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetByUniqueAttributesOpts
} {
	m.lockGetByUniqueAttributes.Lock()
	defer m.lockGetByUniqueAttributes.Unlock()

	return m.calls.GetByUniqueAttributes
}

// GetClusterId mocks base method by wrapping the associated func.
func (m *DefaultApi) GetClusterId(ctx context.Context) (github_com_confluentinc_schema_registry_sdk_go.ServerClusterId, *net_http.Response, error) {
	m.lockGetClusterId.Lock()
	defer m.lockGetClusterId.Unlock()

	if m.GetClusterIdFunc == nil {
		panic("mocker: DefaultApi.GetClusterIdFunc is nil but DefaultApi.GetClusterId was called.")
	}

	call := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}

	m.calls.GetClusterId = append(m.calls.GetClusterId, call)

	return m.GetClusterIdFunc(ctx)
}

// GetClusterIdCalled returns true if GetClusterId was called at least once.
func (m *DefaultApi) GetClusterIdCalled() bool {
	m.lockGetClusterId.Lock()
	defer m.lockGetClusterId.Unlock()

	return len(m.calls.GetClusterId) > 0
}

// GetClusterIdCalls returns the calls made to GetClusterId.
func (m *DefaultApi) GetClusterIdCalls() []struct {
	Ctx context.Context
} {
	m.lockGetClusterId.Lock()
	defer m.lockGetClusterId.Unlock()

	return m.calls.GetClusterId
}

// GetExporterConfig mocks base method by wrapping the associated func.
func (m *DefaultApi) GetExporterConfig(ctx context.Context, name string) (map[string]string, *net_http.Response, error) {
	m.lockGetExporterConfig.Lock()
	defer m.lockGetExporterConfig.Unlock()

	if m.GetExporterConfigFunc == nil {
		panic("mocker: DefaultApi.GetExporterConfigFunc is nil but DefaultApi.GetExporterConfig was called.")
	}

	call := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}

	m.calls.GetExporterConfig = append(m.calls.GetExporterConfig, call)

	return m.GetExporterConfigFunc(ctx, name)
}

// GetExporterConfigCalled returns true if GetExporterConfig was called at least once.
func (m *DefaultApi) GetExporterConfigCalled() bool {
	m.lockGetExporterConfig.Lock()
	defer m.lockGetExporterConfig.Unlock()

	return len(m.calls.GetExporterConfig) > 0
}

// GetExporterConfigCalls returns the calls made to GetExporterConfig.
func (m *DefaultApi) GetExporterConfigCalls() []struct {
	Ctx  context.Context
	Name string
} {
	m.lockGetExporterConfig.Lock()
	defer m.lockGetExporterConfig.Unlock()

	return m.calls.GetExporterConfig
}

// GetExporterInfo mocks base method by wrapping the associated func.
func (m *DefaultApi) GetExporterInfo(ctx context.Context, name string) (github_com_confluentinc_schema_registry_sdk_go.ExporterInfo, *net_http.Response, error) {
	m.lockGetExporterInfo.Lock()
	defer m.lockGetExporterInfo.Unlock()

	if m.GetExporterInfoFunc == nil {
		panic("mocker: DefaultApi.GetExporterInfoFunc is nil but DefaultApi.GetExporterInfo was called.")
	}

	call := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}

	m.calls.GetExporterInfo = append(m.calls.GetExporterInfo, call)

	return m.GetExporterInfoFunc(ctx, name)
}

// GetExporterInfoCalled returns true if GetExporterInfo was called at least once.
func (m *DefaultApi) GetExporterInfoCalled() bool {
	m.lockGetExporterInfo.Lock()
	defer m.lockGetExporterInfo.Unlock()

	return len(m.calls.GetExporterInfo) > 0
}

// GetExporterInfoCalls returns the calls made to GetExporterInfo.
func (m *DefaultApi) GetExporterInfoCalls() []struct {
	Ctx  context.Context
	Name string
} {
	m.lockGetExporterInfo.Lock()
	defer m.lockGetExporterInfo.Unlock()

	return m.calls.GetExporterInfo
}

// GetExporterStatus mocks base method by wrapping the associated func.
func (m *DefaultApi) GetExporterStatus(ctx context.Context, name string) (github_com_confluentinc_schema_registry_sdk_go.ExporterStatus, *net_http.Response, error) {
	m.lockGetExporterStatus.Lock()
	defer m.lockGetExporterStatus.Unlock()

	if m.GetExporterStatusFunc == nil {
		panic("mocker: DefaultApi.GetExporterStatusFunc is nil but DefaultApi.GetExporterStatus was called.")
	}

	call := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}

	m.calls.GetExporterStatus = append(m.calls.GetExporterStatus, call)

	return m.GetExporterStatusFunc(ctx, name)
}

// GetExporterStatusCalled returns true if GetExporterStatus was called at least once.
func (m *DefaultApi) GetExporterStatusCalled() bool {
	m.lockGetExporterStatus.Lock()
	defer m.lockGetExporterStatus.Unlock()

	return len(m.calls.GetExporterStatus) > 0
}

// GetExporterStatusCalls returns the calls made to GetExporterStatus.
func (m *DefaultApi) GetExporterStatusCalls() []struct {
	Ctx  context.Context
	Name string
} {
	m.lockGetExporterStatus.Lock()
	defer m.lockGetExporterStatus.Unlock()

	return m.calls.GetExporterStatus
}

// GetExporters mocks base method by wrapping the associated func.
func (m *DefaultApi) GetExporters(ctx context.Context) ([]string, *net_http.Response, error) {
	m.lockGetExporters.Lock()
	defer m.lockGetExporters.Unlock()

	if m.GetExportersFunc == nil {
		panic("mocker: DefaultApi.GetExportersFunc is nil but DefaultApi.GetExporters was called.")
	}

	call := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}

	m.calls.GetExporters = append(m.calls.GetExporters, call)

	return m.GetExportersFunc(ctx)
}

// GetExportersCalled returns true if GetExporters was called at least once.
func (m *DefaultApi) GetExportersCalled() bool {
	m.lockGetExporters.Lock()
	defer m.lockGetExporters.Unlock()

	return len(m.calls.GetExporters) > 0
}

// GetExportersCalls returns the calls made to GetExporters.
func (m *DefaultApi) GetExportersCalls() []struct {
	Ctx context.Context
} {
	m.lockGetExporters.Lock()
	defer m.lockGetExporters.Unlock()

	return m.calls.GetExporters
}

// GetMode mocks base method by wrapping the associated func.
func (m *DefaultApi) GetMode(ctx context.Context, subject string, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetModeOpts) (github_com_confluentinc_schema_registry_sdk_go.Mode, *net_http.Response, error) {
	m.lockGetMode.Lock()
	defer m.lockGetMode.Unlock()

	if m.GetModeFunc == nil {
		panic("mocker: DefaultApi.GetModeFunc is nil but DefaultApi.GetMode was called.")
	}

	call := struct {
		Ctx               context.Context
		Subject           string
		LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetModeOpts
	}{
		Ctx:               ctx,
		Subject:           subject,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.GetMode = append(m.calls.GetMode, call)

	return m.GetModeFunc(ctx, subject, localVarOptionals)
}

// GetModeCalled returns true if GetMode was called at least once.
func (m *DefaultApi) GetModeCalled() bool {
	m.lockGetMode.Lock()
	defer m.lockGetMode.Unlock()

	return len(m.calls.GetMode) > 0
}

// GetModeCalls returns the calls made to GetMode.
func (m *DefaultApi) GetModeCalls() []struct {
	Ctx               context.Context
	Subject           string
	LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetModeOpts
} {
	m.lockGetMode.Lock()
	defer m.lockGetMode.Unlock()

	return m.calls.GetMode
}

// GetReferencedBy mocks base method by wrapping the associated func.
func (m *DefaultApi) GetReferencedBy(ctx context.Context, subject, version string) ([]int32, *net_http.Response, error) {
	m.lockGetReferencedBy.Lock()
	defer m.lockGetReferencedBy.Unlock()

	if m.GetReferencedByFunc == nil {
		panic("mocker: DefaultApi.GetReferencedByFunc is nil but DefaultApi.GetReferencedBy was called.")
	}

	call := struct {
		Ctx     context.Context
		Subject string
		Version string
	}{
		Ctx:     ctx,
		Subject: subject,
		Version: version,
	}

	m.calls.GetReferencedBy = append(m.calls.GetReferencedBy, call)

	return m.GetReferencedByFunc(ctx, subject, version)
}

// GetReferencedByCalled returns true if GetReferencedBy was called at least once.
func (m *DefaultApi) GetReferencedByCalled() bool {
	m.lockGetReferencedBy.Lock()
	defer m.lockGetReferencedBy.Unlock()

	return len(m.calls.GetReferencedBy) > 0
}

// GetReferencedByCalls returns the calls made to GetReferencedBy.
func (m *DefaultApi) GetReferencedByCalls() []struct {
	Ctx     context.Context
	Subject string
	Version string
} {
	m.lockGetReferencedBy.Lock()
	defer m.lockGetReferencedBy.Unlock()

	return m.calls.GetReferencedBy
}

// GetSchema mocks base method by wrapping the associated func.
func (m *DefaultApi) GetSchema(ctx context.Context, id int32, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetSchemaOpts) (github_com_confluentinc_schema_registry_sdk_go.SchemaString, *net_http.Response, error) {
	m.lockGetSchema.Lock()
	defer m.lockGetSchema.Unlock()

	if m.GetSchemaFunc == nil {
		panic("mocker: DefaultApi.GetSchemaFunc is nil but DefaultApi.GetSchema was called.")
	}

	call := struct {
		Ctx               context.Context
		Id                int32
		LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetSchemaOpts
	}{
		Ctx:               ctx,
		Id:                id,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.GetSchema = append(m.calls.GetSchema, call)

	return m.GetSchemaFunc(ctx, id, localVarOptionals)
}

// GetSchemaCalled returns true if GetSchema was called at least once.
func (m *DefaultApi) GetSchemaCalled() bool {
	m.lockGetSchema.Lock()
	defer m.lockGetSchema.Unlock()

	return len(m.calls.GetSchema) > 0
}

// GetSchemaCalls returns the calls made to GetSchema.
func (m *DefaultApi) GetSchemaCalls() []struct {
	Ctx               context.Context
	Id                int32
	LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetSchemaOpts
} {
	m.lockGetSchema.Lock()
	defer m.lockGetSchema.Unlock()

	return m.calls.GetSchema
}

// GetSchemaByVersion mocks base method by wrapping the associated func.
func (m *DefaultApi) GetSchemaByVersion(ctx context.Context, subject, version string, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetSchemaByVersionOpts) (github_com_confluentinc_schema_registry_sdk_go.Schema, *net_http.Response, error) {
	m.lockGetSchemaByVersion.Lock()
	defer m.lockGetSchemaByVersion.Unlock()

	if m.GetSchemaByVersionFunc == nil {
		panic("mocker: DefaultApi.GetSchemaByVersionFunc is nil but DefaultApi.GetSchemaByVersion was called.")
	}

	call := struct {
		Ctx               context.Context
		Subject           string
		Version           string
		LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetSchemaByVersionOpts
	}{
		Ctx:               ctx,
		Subject:           subject,
		Version:           version,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.GetSchemaByVersion = append(m.calls.GetSchemaByVersion, call)

	return m.GetSchemaByVersionFunc(ctx, subject, version, localVarOptionals)
}

// GetSchemaByVersionCalled returns true if GetSchemaByVersion was called at least once.
func (m *DefaultApi) GetSchemaByVersionCalled() bool {
	m.lockGetSchemaByVersion.Lock()
	defer m.lockGetSchemaByVersion.Unlock()

	return len(m.calls.GetSchemaByVersion) > 0
}

// GetSchemaByVersionCalls returns the calls made to GetSchemaByVersion.
func (m *DefaultApi) GetSchemaByVersionCalls() []struct {
	Ctx               context.Context
	Subject           string
	Version           string
	LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetSchemaByVersionOpts
} {
	m.lockGetSchemaByVersion.Lock()
	defer m.lockGetSchemaByVersion.Unlock()

	return m.calls.GetSchemaByVersion
}

// GetSchemaOnly mocks base method by wrapping the associated func.
func (m *DefaultApi) GetSchemaOnly(ctx context.Context, subject, version string, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetSchemaOnlyOpts) (string, *net_http.Response, error) {
	m.lockGetSchemaOnly.Lock()
	defer m.lockGetSchemaOnly.Unlock()

	if m.GetSchemaOnlyFunc == nil {
		panic("mocker: DefaultApi.GetSchemaOnlyFunc is nil but DefaultApi.GetSchemaOnly was called.")
	}

	call := struct {
		Ctx               context.Context
		Subject           string
		Version           string
		LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetSchemaOnlyOpts
	}{
		Ctx:               ctx,
		Subject:           subject,
		Version:           version,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.GetSchemaOnly = append(m.calls.GetSchemaOnly, call)

	return m.GetSchemaOnlyFunc(ctx, subject, version, localVarOptionals)
}

// GetSchemaOnlyCalled returns true if GetSchemaOnly was called at least once.
func (m *DefaultApi) GetSchemaOnlyCalled() bool {
	m.lockGetSchemaOnly.Lock()
	defer m.lockGetSchemaOnly.Unlock()

	return len(m.calls.GetSchemaOnly) > 0
}

// GetSchemaOnlyCalls returns the calls made to GetSchemaOnly.
func (m *DefaultApi) GetSchemaOnlyCalls() []struct {
	Ctx               context.Context
	Subject           string
	Version           string
	LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetSchemaOnlyOpts
} {
	m.lockGetSchemaOnly.Lock()
	defer m.lockGetSchemaOnly.Unlock()

	return m.calls.GetSchemaOnly
}

// GetSchemaTypes mocks base method by wrapping the associated func.
func (m *DefaultApi) GetSchemaTypes(ctx context.Context) ([]string, *net_http.Response, error) {
	m.lockGetSchemaTypes.Lock()
	defer m.lockGetSchemaTypes.Unlock()

	if m.GetSchemaTypesFunc == nil {
		panic("mocker: DefaultApi.GetSchemaTypesFunc is nil but DefaultApi.GetSchemaTypes was called.")
	}

	call := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}

	m.calls.GetSchemaTypes = append(m.calls.GetSchemaTypes, call)

	return m.GetSchemaTypesFunc(ctx)
}

// GetSchemaTypesCalled returns true if GetSchemaTypes was called at least once.
func (m *DefaultApi) GetSchemaTypesCalled() bool {
	m.lockGetSchemaTypes.Lock()
	defer m.lockGetSchemaTypes.Unlock()

	return len(m.calls.GetSchemaTypes) > 0
}

// GetSchemaTypesCalls returns the calls made to GetSchemaTypes.
func (m *DefaultApi) GetSchemaTypesCalls() []struct {
	Ctx context.Context
} {
	m.lockGetSchemaTypes.Lock()
	defer m.lockGetSchemaTypes.Unlock()

	return m.calls.GetSchemaTypes
}

// GetSchemas mocks base method by wrapping the associated func.
func (m *DefaultApi) GetSchemas(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetSchemasOpts) ([]github_com_confluentinc_schema_registry_sdk_go.Schema, *net_http.Response, error) {
	m.lockGetSchemas.Lock()
	defer m.lockGetSchemas.Unlock()

	if m.GetSchemasFunc == nil {
		panic("mocker: DefaultApi.GetSchemasFunc is nil but DefaultApi.GetSchemas was called.")
	}

	call := struct {
		Ctx               context.Context
		LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetSchemasOpts
	}{
		Ctx:               ctx,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.GetSchemas = append(m.calls.GetSchemas, call)

	return m.GetSchemasFunc(ctx, localVarOptionals)
}

// GetSchemasCalled returns true if GetSchemas was called at least once.
func (m *DefaultApi) GetSchemasCalled() bool {
	m.lockGetSchemas.Lock()
	defer m.lockGetSchemas.Unlock()

	return len(m.calls.GetSchemas) > 0
}

// GetSchemasCalls returns the calls made to GetSchemas.
func (m *DefaultApi) GetSchemasCalls() []struct {
	Ctx               context.Context
	LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetSchemasOpts
} {
	m.lockGetSchemas.Lock()
	defer m.lockGetSchemas.Unlock()

	return m.calls.GetSchemas
}

// GetSubjectLevelConfig mocks base method by wrapping the associated func.
func (m *DefaultApi) GetSubjectLevelConfig(ctx context.Context, subject string, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetSubjectLevelConfigOpts) (github_com_confluentinc_schema_registry_sdk_go.Config, *net_http.Response, error) {
	m.lockGetSubjectLevelConfig.Lock()
	defer m.lockGetSubjectLevelConfig.Unlock()

	if m.GetSubjectLevelConfigFunc == nil {
		panic("mocker: DefaultApi.GetSubjectLevelConfigFunc is nil but DefaultApi.GetSubjectLevelConfig was called.")
	}

	call := struct {
		Ctx               context.Context
		Subject           string
		LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetSubjectLevelConfigOpts
	}{
		Ctx:               ctx,
		Subject:           subject,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.GetSubjectLevelConfig = append(m.calls.GetSubjectLevelConfig, call)

	return m.GetSubjectLevelConfigFunc(ctx, subject, localVarOptionals)
}

// GetSubjectLevelConfigCalled returns true if GetSubjectLevelConfig was called at least once.
func (m *DefaultApi) GetSubjectLevelConfigCalled() bool {
	m.lockGetSubjectLevelConfig.Lock()
	defer m.lockGetSubjectLevelConfig.Unlock()

	return len(m.calls.GetSubjectLevelConfig) > 0
}

// GetSubjectLevelConfigCalls returns the calls made to GetSubjectLevelConfig.
func (m *DefaultApi) GetSubjectLevelConfigCalls() []struct {
	Ctx               context.Context
	Subject           string
	LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetSubjectLevelConfigOpts
} {
	m.lockGetSubjectLevelConfig.Lock()
	defer m.lockGetSubjectLevelConfig.Unlock()

	return m.calls.GetSubjectLevelConfig
}

// GetSubjects mocks base method by wrapping the associated func.
func (m *DefaultApi) GetSubjects(ctx context.Context, id int32, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetSubjectsOpts) ([]string, *net_http.Response, error) {
	m.lockGetSubjects.Lock()
	defer m.lockGetSubjects.Unlock()

	if m.GetSubjectsFunc == nil {
		panic("mocker: DefaultApi.GetSubjectsFunc is nil but DefaultApi.GetSubjects was called.")
	}

	call := struct {
		Ctx               context.Context
		Id                int32
		LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetSubjectsOpts
	}{
		Ctx:               ctx,
		Id:                id,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.GetSubjects = append(m.calls.GetSubjects, call)

	return m.GetSubjectsFunc(ctx, id, localVarOptionals)
}

// GetSubjectsCalled returns true if GetSubjects was called at least once.
func (m *DefaultApi) GetSubjectsCalled() bool {
	m.lockGetSubjects.Lock()
	defer m.lockGetSubjects.Unlock()

	return len(m.calls.GetSubjects) > 0
}

// GetSubjectsCalls returns the calls made to GetSubjects.
func (m *DefaultApi) GetSubjectsCalls() []struct {
	Ctx               context.Context
	Id                int32
	LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetSubjectsOpts
} {
	m.lockGetSubjects.Lock()
	defer m.lockGetSubjects.Unlock()

	return m.calls.GetSubjects
}

// GetTagDefByName mocks base method by wrapping the associated func.
func (m *DefaultApi) GetTagDefByName(ctx context.Context, tagName string) (github_com_confluentinc_schema_registry_sdk_go.TagDef, *net_http.Response, error) {
	m.lockGetTagDefByName.Lock()
	defer m.lockGetTagDefByName.Unlock()

	if m.GetTagDefByNameFunc == nil {
		panic("mocker: DefaultApi.GetTagDefByNameFunc is nil but DefaultApi.GetTagDefByName was called.")
	}

	call := struct {
		Ctx     context.Context
		TagName string
	}{
		Ctx:     ctx,
		TagName: tagName,
	}

	m.calls.GetTagDefByName = append(m.calls.GetTagDefByName, call)

	return m.GetTagDefByNameFunc(ctx, tagName)
}

// GetTagDefByNameCalled returns true if GetTagDefByName was called at least once.
func (m *DefaultApi) GetTagDefByNameCalled() bool {
	m.lockGetTagDefByName.Lock()
	defer m.lockGetTagDefByName.Unlock()

	return len(m.calls.GetTagDefByName) > 0
}

// GetTagDefByNameCalls returns the calls made to GetTagDefByName.
func (m *DefaultApi) GetTagDefByNameCalls() []struct {
	Ctx     context.Context
	TagName string
} {
	m.lockGetTagDefByName.Lock()
	defer m.lockGetTagDefByName.Unlock()

	return m.calls.GetTagDefByName
}

// GetTags mocks base method by wrapping the associated func.
func (m *DefaultApi) GetTags(ctx context.Context, typeName, qualifiedName string) ([]github_com_confluentinc_schema_registry_sdk_go.TagResponse, *net_http.Response, error) {
	m.lockGetTags.Lock()
	defer m.lockGetTags.Unlock()

	if m.GetTagsFunc == nil {
		panic("mocker: DefaultApi.GetTagsFunc is nil but DefaultApi.GetTags was called.")
	}

	call := struct {
		Ctx           context.Context
		TypeName      string
		QualifiedName string
	}{
		Ctx:           ctx,
		TypeName:      typeName,
		QualifiedName: qualifiedName,
	}

	m.calls.GetTags = append(m.calls.GetTags, call)

	return m.GetTagsFunc(ctx, typeName, qualifiedName)
}

// GetTagsCalled returns true if GetTags was called at least once.
func (m *DefaultApi) GetTagsCalled() bool {
	m.lockGetTags.Lock()
	defer m.lockGetTags.Unlock()

	return len(m.calls.GetTags) > 0
}

// GetTagsCalls returns the calls made to GetTags.
func (m *DefaultApi) GetTagsCalls() []struct {
	Ctx           context.Context
	TypeName      string
	QualifiedName string
} {
	m.lockGetTags.Lock()
	defer m.lockGetTags.Unlock()

	return m.calls.GetTags
}

// GetTopLevelConfig mocks base method by wrapping the associated func.
func (m *DefaultApi) GetTopLevelConfig(ctx context.Context) (github_com_confluentinc_schema_registry_sdk_go.Config, *net_http.Response, error) {
	m.lockGetTopLevelConfig.Lock()
	defer m.lockGetTopLevelConfig.Unlock()

	if m.GetTopLevelConfigFunc == nil {
		panic("mocker: DefaultApi.GetTopLevelConfigFunc is nil but DefaultApi.GetTopLevelConfig was called.")
	}

	call := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}

	m.calls.GetTopLevelConfig = append(m.calls.GetTopLevelConfig, call)

	return m.GetTopLevelConfigFunc(ctx)
}

// GetTopLevelConfigCalled returns true if GetTopLevelConfig was called at least once.
func (m *DefaultApi) GetTopLevelConfigCalled() bool {
	m.lockGetTopLevelConfig.Lock()
	defer m.lockGetTopLevelConfig.Unlock()

	return len(m.calls.GetTopLevelConfig) > 0
}

// GetTopLevelConfigCalls returns the calls made to GetTopLevelConfig.
func (m *DefaultApi) GetTopLevelConfigCalls() []struct {
	Ctx context.Context
} {
	m.lockGetTopLevelConfig.Lock()
	defer m.lockGetTopLevelConfig.Unlock()

	return m.calls.GetTopLevelConfig
}

// GetTopLevelMode mocks base method by wrapping the associated func.
func (m *DefaultApi) GetTopLevelMode(ctx context.Context) (github_com_confluentinc_schema_registry_sdk_go.Mode, *net_http.Response, error) {
	m.lockGetTopLevelMode.Lock()
	defer m.lockGetTopLevelMode.Unlock()

	if m.GetTopLevelModeFunc == nil {
		panic("mocker: DefaultApi.GetTopLevelModeFunc is nil but DefaultApi.GetTopLevelMode was called.")
	}

	call := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}

	m.calls.GetTopLevelMode = append(m.calls.GetTopLevelMode, call)

	return m.GetTopLevelModeFunc(ctx)
}

// GetTopLevelModeCalled returns true if GetTopLevelMode was called at least once.
func (m *DefaultApi) GetTopLevelModeCalled() bool {
	m.lockGetTopLevelMode.Lock()
	defer m.lockGetTopLevelMode.Unlock()

	return len(m.calls.GetTopLevelMode) > 0
}

// GetTopLevelModeCalls returns the calls made to GetTopLevelMode.
func (m *DefaultApi) GetTopLevelModeCalls() []struct {
	Ctx context.Context
} {
	m.lockGetTopLevelMode.Lock()
	defer m.lockGetTopLevelMode.Unlock()

	return m.calls.GetTopLevelMode
}

// GetVersions mocks base method by wrapping the associated func.
func (m *DefaultApi) GetVersions(ctx context.Context, id int32, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetVersionsOpts) ([]github_com_confluentinc_schema_registry_sdk_go.SubjectVersion, *net_http.Response, error) {
	m.lockGetVersions.Lock()
	defer m.lockGetVersions.Unlock()

	if m.GetVersionsFunc == nil {
		panic("mocker: DefaultApi.GetVersionsFunc is nil but DefaultApi.GetVersions was called.")
	}

	call := struct {
		Ctx               context.Context
		Id                int32
		LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetVersionsOpts
	}{
		Ctx:               ctx,
		Id:                id,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.GetVersions = append(m.calls.GetVersions, call)

	return m.GetVersionsFunc(ctx, id, localVarOptionals)
}

// GetVersionsCalled returns true if GetVersions was called at least once.
func (m *DefaultApi) GetVersionsCalled() bool {
	m.lockGetVersions.Lock()
	defer m.lockGetVersions.Unlock()

	return len(m.calls.GetVersions) > 0
}

// GetVersionsCalls returns the calls made to GetVersions.
func (m *DefaultApi) GetVersionsCalls() []struct {
	Ctx               context.Context
	Id                int32
	LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.GetVersionsOpts
} {
	m.lockGetVersions.Lock()
	defer m.lockGetVersions.Unlock()

	return m.calls.GetVersions
}

// List mocks base method by wrapping the associated func.
func (m *DefaultApi) List(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.ListOpts) ([]string, *net_http.Response, error) {
	m.lockList.Lock()
	defer m.lockList.Unlock()

	if m.ListFunc == nil {
		panic("mocker: DefaultApi.ListFunc is nil but DefaultApi.List was called.")
	}

	call := struct {
		Ctx               context.Context
		LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.ListOpts
	}{
		Ctx:               ctx,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.List = append(m.calls.List, call)

	return m.ListFunc(ctx, localVarOptionals)
}

// ListCalled returns true if List was called at least once.
func (m *DefaultApi) ListCalled() bool {
	m.lockList.Lock()
	defer m.lockList.Unlock()

	return len(m.calls.List) > 0
}

// ListCalls returns the calls made to List.
func (m *DefaultApi) ListCalls() []struct {
	Ctx               context.Context
	LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.ListOpts
} {
	m.lockList.Lock()
	defer m.lockList.Unlock()

	return m.calls.List
}

// ListContexts mocks base method by wrapping the associated func.
func (m *DefaultApi) ListContexts(ctx context.Context) ([]string, *net_http.Response, error) {
	m.lockListContexts.Lock()
	defer m.lockListContexts.Unlock()

	if m.ListContextsFunc == nil {
		panic("mocker: DefaultApi.ListContextsFunc is nil but DefaultApi.ListContexts was called.")
	}

	call := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}

	m.calls.ListContexts = append(m.calls.ListContexts, call)

	return m.ListContextsFunc(ctx)
}

// ListContextsCalled returns true if ListContexts was called at least once.
func (m *DefaultApi) ListContextsCalled() bool {
	m.lockListContexts.Lock()
	defer m.lockListContexts.Unlock()

	return len(m.calls.ListContexts) > 0
}

// ListContextsCalls returns the calls made to ListContexts.
func (m *DefaultApi) ListContextsCalls() []struct {
	Ctx context.Context
} {
	m.lockListContexts.Lock()
	defer m.lockListContexts.Unlock()

	return m.calls.ListContexts
}

// ListVersions mocks base method by wrapping the associated func.
func (m *DefaultApi) ListVersions(ctx context.Context, subject string, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.ListVersionsOpts) ([]int32, *net_http.Response, error) {
	m.lockListVersions.Lock()
	defer m.lockListVersions.Unlock()

	if m.ListVersionsFunc == nil {
		panic("mocker: DefaultApi.ListVersionsFunc is nil but DefaultApi.ListVersions was called.")
	}

	call := struct {
		Ctx               context.Context
		Subject           string
		LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.ListVersionsOpts
	}{
		Ctx:               ctx,
		Subject:           subject,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.ListVersions = append(m.calls.ListVersions, call)

	return m.ListVersionsFunc(ctx, subject, localVarOptionals)
}

// ListVersionsCalled returns true if ListVersions was called at least once.
func (m *DefaultApi) ListVersionsCalled() bool {
	m.lockListVersions.Lock()
	defer m.lockListVersions.Unlock()

	return len(m.calls.ListVersions) > 0
}

// ListVersionsCalls returns the calls made to ListVersions.
func (m *DefaultApi) ListVersionsCalls() []struct {
	Ctx               context.Context
	Subject           string
	LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.ListVersionsOpts
} {
	m.lockListVersions.Lock()
	defer m.lockListVersions.Unlock()

	return m.calls.ListVersions
}

// LookUpSchemaUnderSubject mocks base method by wrapping the associated func.
func (m *DefaultApi) LookUpSchemaUnderSubject(ctx context.Context, subject string, body github_com_confluentinc_schema_registry_sdk_go.RegisterSchemaRequest, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.LookUpSchemaUnderSubjectOpts) (*net_http.Response, error) {
	m.lockLookUpSchemaUnderSubject.Lock()
	defer m.lockLookUpSchemaUnderSubject.Unlock()

	if m.LookUpSchemaUnderSubjectFunc == nil {
		panic("mocker: DefaultApi.LookUpSchemaUnderSubjectFunc is nil but DefaultApi.LookUpSchemaUnderSubject was called.")
	}

	call := struct {
		Ctx               context.Context
		Subject           string
		Body              github_com_confluentinc_schema_registry_sdk_go.RegisterSchemaRequest
		LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.LookUpSchemaUnderSubjectOpts
	}{
		Ctx:               ctx,
		Subject:           subject,
		Body:              body,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.LookUpSchemaUnderSubject = append(m.calls.LookUpSchemaUnderSubject, call)

	return m.LookUpSchemaUnderSubjectFunc(ctx, subject, body, localVarOptionals)
}

// LookUpSchemaUnderSubjectCalled returns true if LookUpSchemaUnderSubject was called at least once.
func (m *DefaultApi) LookUpSchemaUnderSubjectCalled() bool {
	m.lockLookUpSchemaUnderSubject.Lock()
	defer m.lockLookUpSchemaUnderSubject.Unlock()

	return len(m.calls.LookUpSchemaUnderSubject) > 0
}

// LookUpSchemaUnderSubjectCalls returns the calls made to LookUpSchemaUnderSubject.
func (m *DefaultApi) LookUpSchemaUnderSubjectCalls() []struct {
	Ctx               context.Context
	Subject           string
	Body              github_com_confluentinc_schema_registry_sdk_go.RegisterSchemaRequest
	LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.LookUpSchemaUnderSubjectOpts
} {
	m.lockLookUpSchemaUnderSubject.Lock()
	defer m.lockLookUpSchemaUnderSubject.Unlock()

	return m.calls.LookUpSchemaUnderSubject
}

// PartialUpdateByUniqueAttributes mocks base method by wrapping the associated func.
func (m *DefaultApi) PartialUpdateByUniqueAttributes(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.PartialUpdateByUniqueAttributesOpts) (*net_http.Response, error) {
	m.lockPartialUpdateByUniqueAttributes.Lock()
	defer m.lockPartialUpdateByUniqueAttributes.Unlock()

	if m.PartialUpdateByUniqueAttributesFunc == nil {
		panic("mocker: DefaultApi.PartialUpdateByUniqueAttributesFunc is nil but DefaultApi.PartialUpdateByUniqueAttributes was called.")
	}

	call := struct {
		Ctx               context.Context
		LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.PartialUpdateByUniqueAttributesOpts
	}{
		Ctx:               ctx,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.PartialUpdateByUniqueAttributes = append(m.calls.PartialUpdateByUniqueAttributes, call)

	return m.PartialUpdateByUniqueAttributesFunc(ctx, localVarOptionals)
}

// PartialUpdateByUniqueAttributesCalled returns true if PartialUpdateByUniqueAttributes was called at least once.
func (m *DefaultApi) PartialUpdateByUniqueAttributesCalled() bool {
	m.lockPartialUpdateByUniqueAttributes.Lock()
	defer m.lockPartialUpdateByUniqueAttributes.Unlock()

	return len(m.calls.PartialUpdateByUniqueAttributes) > 0
}

// PartialUpdateByUniqueAttributesCalls returns the calls made to PartialUpdateByUniqueAttributes.
func (m *DefaultApi) PartialUpdateByUniqueAttributesCalls() []struct {
	Ctx               context.Context
	LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.PartialUpdateByUniqueAttributesOpts
} {
	m.lockPartialUpdateByUniqueAttributes.Lock()
	defer m.lockPartialUpdateByUniqueAttributes.Unlock()

	return m.calls.PartialUpdateByUniqueAttributes
}

// PauseExporter mocks base method by wrapping the associated func.
func (m *DefaultApi) PauseExporter(ctx context.Context, name string) (github_com_confluentinc_schema_registry_sdk_go.UpdateExporterResponse, *net_http.Response, error) {
	m.lockPauseExporter.Lock()
	defer m.lockPauseExporter.Unlock()

	if m.PauseExporterFunc == nil {
		panic("mocker: DefaultApi.PauseExporterFunc is nil but DefaultApi.PauseExporter was called.")
	}

	call := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}

	m.calls.PauseExporter = append(m.calls.PauseExporter, call)

	return m.PauseExporterFunc(ctx, name)
}

// PauseExporterCalled returns true if PauseExporter was called at least once.
func (m *DefaultApi) PauseExporterCalled() bool {
	m.lockPauseExporter.Lock()
	defer m.lockPauseExporter.Unlock()

	return len(m.calls.PauseExporter) > 0
}

// PauseExporterCalls returns the calls made to PauseExporter.
func (m *DefaultApi) PauseExporterCalls() []struct {
	Ctx  context.Context
	Name string
} {
	m.lockPauseExporter.Lock()
	defer m.lockPauseExporter.Unlock()

	return m.calls.PauseExporter
}

// Post mocks base method by wrapping the associated func.
func (m *DefaultApi) Post(ctx context.Context) (map[string]string, *net_http.Response, error) {
	m.lockPost.Lock()
	defer m.lockPost.Unlock()

	if m.PostFunc == nil {
		panic("mocker: DefaultApi.PostFunc is nil but DefaultApi.Post was called.")
	}

	call := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}

	m.calls.Post = append(m.calls.Post, call)

	return m.PostFunc(ctx)
}

// PostCalled returns true if Post was called at least once.
func (m *DefaultApi) PostCalled() bool {
	m.lockPost.Lock()
	defer m.lockPost.Unlock()

	return len(m.calls.Post) > 0
}

// PostCalls returns the calls made to Post.
func (m *DefaultApi) PostCalls() []struct {
	Ctx context.Context
} {
	m.lockPost.Lock()
	defer m.lockPost.Unlock()

	return m.calls.Post
}

// PutExporter mocks base method by wrapping the associated func.
func (m *DefaultApi) PutExporter(ctx context.Context, name string, body github_com_confluentinc_schema_registry_sdk_go.UpdateExporterRequest) (github_com_confluentinc_schema_registry_sdk_go.UpdateExporterResponse, *net_http.Response, error) {
	m.lockPutExporter.Lock()
	defer m.lockPutExporter.Unlock()

	if m.PutExporterFunc == nil {
		panic("mocker: DefaultApi.PutExporterFunc is nil but DefaultApi.PutExporter was called.")
	}

	call := struct {
		Ctx  context.Context
		Name string
		Body github_com_confluentinc_schema_registry_sdk_go.UpdateExporterRequest
	}{
		Ctx:  ctx,
		Name: name,
		Body: body,
	}

	m.calls.PutExporter = append(m.calls.PutExporter, call)

	return m.PutExporterFunc(ctx, name, body)
}

// PutExporterCalled returns true if PutExporter was called at least once.
func (m *DefaultApi) PutExporterCalled() bool {
	m.lockPutExporter.Lock()
	defer m.lockPutExporter.Unlock()

	return len(m.calls.PutExporter) > 0
}

// PutExporterCalls returns the calls made to PutExporter.
func (m *DefaultApi) PutExporterCalls() []struct {
	Ctx  context.Context
	Name string
	Body github_com_confluentinc_schema_registry_sdk_go.UpdateExporterRequest
} {
	m.lockPutExporter.Lock()
	defer m.lockPutExporter.Unlock()

	return m.calls.PutExporter
}

// PutExporterConfig mocks base method by wrapping the associated func.
func (m *DefaultApi) PutExporterConfig(ctx context.Context, name string, body map[string]string) (github_com_confluentinc_schema_registry_sdk_go.UpdateExporterResponse, *net_http.Response, error) {
	m.lockPutExporterConfig.Lock()
	defer m.lockPutExporterConfig.Unlock()

	if m.PutExporterConfigFunc == nil {
		panic("mocker: DefaultApi.PutExporterConfigFunc is nil but DefaultApi.PutExporterConfig was called.")
	}

	call := struct {
		Ctx  context.Context
		Name string
		Body map[string]string
	}{
		Ctx:  ctx,
		Name: name,
		Body: body,
	}

	m.calls.PutExporterConfig = append(m.calls.PutExporterConfig, call)

	return m.PutExporterConfigFunc(ctx, name, body)
}

// PutExporterConfigCalled returns true if PutExporterConfig was called at least once.
func (m *DefaultApi) PutExporterConfigCalled() bool {
	m.lockPutExporterConfig.Lock()
	defer m.lockPutExporterConfig.Unlock()

	return len(m.calls.PutExporterConfig) > 0
}

// PutExporterConfigCalls returns the calls made to PutExporterConfig.
func (m *DefaultApi) PutExporterConfigCalls() []struct {
	Ctx  context.Context
	Name string
	Body map[string]string
} {
	m.lockPutExporterConfig.Lock()
	defer m.lockPutExporterConfig.Unlock()

	return m.calls.PutExporterConfig
}

// Register mocks base method by wrapping the associated func.
func (m *DefaultApi) Register(ctx context.Context, subject string, body github_com_confluentinc_schema_registry_sdk_go.RegisterSchemaRequest) (github_com_confluentinc_schema_registry_sdk_go.RegisterSchemaResponse, *net_http.Response, error) {
	m.lockRegister.Lock()
	defer m.lockRegister.Unlock()

	if m.RegisterFunc == nil {
		panic("mocker: DefaultApi.RegisterFunc is nil but DefaultApi.Register was called.")
	}

	call := struct {
		Ctx     context.Context
		Subject string
		Body    github_com_confluentinc_schema_registry_sdk_go.RegisterSchemaRequest
	}{
		Ctx:     ctx,
		Subject: subject,
		Body:    body,
	}

	m.calls.Register = append(m.calls.Register, call)

	return m.RegisterFunc(ctx, subject, body)
}

// RegisterCalled returns true if Register was called at least once.
func (m *DefaultApi) RegisterCalled() bool {
	m.lockRegister.Lock()
	defer m.lockRegister.Unlock()

	return len(m.calls.Register) > 0
}

// RegisterCalls returns the calls made to Register.
func (m *DefaultApi) RegisterCalls() []struct {
	Ctx     context.Context
	Subject string
	Body    github_com_confluentinc_schema_registry_sdk_go.RegisterSchemaRequest
} {
	m.lockRegister.Lock()
	defer m.lockRegister.Unlock()

	return m.calls.Register
}

// ResetExporter mocks base method by wrapping the associated func.
func (m *DefaultApi) ResetExporter(ctx context.Context, name string) (github_com_confluentinc_schema_registry_sdk_go.UpdateExporterResponse, *net_http.Response, error) {
	m.lockResetExporter.Lock()
	defer m.lockResetExporter.Unlock()

	if m.ResetExporterFunc == nil {
		panic("mocker: DefaultApi.ResetExporterFunc is nil but DefaultApi.ResetExporter was called.")
	}

	call := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}

	m.calls.ResetExporter = append(m.calls.ResetExporter, call)

	return m.ResetExporterFunc(ctx, name)
}

// ResetExporterCalled returns true if ResetExporter was called at least once.
func (m *DefaultApi) ResetExporterCalled() bool {
	m.lockResetExporter.Lock()
	defer m.lockResetExporter.Unlock()

	return len(m.calls.ResetExporter) > 0
}

// ResetExporterCalls returns the calls made to ResetExporter.
func (m *DefaultApi) ResetExporterCalls() []struct {
	Ctx  context.Context
	Name string
} {
	m.lockResetExporter.Lock()
	defer m.lockResetExporter.Unlock()

	return m.calls.ResetExporter
}

// ResumeExporter mocks base method by wrapping the associated func.
func (m *DefaultApi) ResumeExporter(ctx context.Context, name string) (github_com_confluentinc_schema_registry_sdk_go.UpdateExporterResponse, *net_http.Response, error) {
	m.lockResumeExporter.Lock()
	defer m.lockResumeExporter.Unlock()

	if m.ResumeExporterFunc == nil {
		panic("mocker: DefaultApi.ResumeExporterFunc is nil but DefaultApi.ResumeExporter was called.")
	}

	call := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}

	m.calls.ResumeExporter = append(m.calls.ResumeExporter, call)

	return m.ResumeExporterFunc(ctx, name)
}

// ResumeExporterCalled returns true if ResumeExporter was called at least once.
func (m *DefaultApi) ResumeExporterCalled() bool {
	m.lockResumeExporter.Lock()
	defer m.lockResumeExporter.Unlock()

	return len(m.calls.ResumeExporter) > 0
}

// ResumeExporterCalls returns the calls made to ResumeExporter.
func (m *DefaultApi) ResumeExporterCalls() []struct {
	Ctx  context.Context
	Name string
} {
	m.lockResumeExporter.Lock()
	defer m.lockResumeExporter.Unlock()

	return m.calls.ResumeExporter
}

// SearchUsingAttribute mocks base method by wrapping the associated func.
func (m *DefaultApi) SearchUsingAttribute(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.SearchUsingAttributeOpts) (github_com_confluentinc_schema_registry_sdk_go.SearchResult, *net_http.Response, error) {
	m.lockSearchUsingAttribute.Lock()
	defer m.lockSearchUsingAttribute.Unlock()

	if m.SearchUsingAttributeFunc == nil {
		panic("mocker: DefaultApi.SearchUsingAttributeFunc is nil but DefaultApi.SearchUsingAttribute was called.")
	}

	call := struct {
		Ctx               context.Context
		LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.SearchUsingAttributeOpts
	}{
		Ctx:               ctx,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.SearchUsingAttribute = append(m.calls.SearchUsingAttribute, call)

	return m.SearchUsingAttributeFunc(ctx, localVarOptionals)
}

// SearchUsingAttributeCalled returns true if SearchUsingAttribute was called at least once.
func (m *DefaultApi) SearchUsingAttributeCalled() bool {
	m.lockSearchUsingAttribute.Lock()
	defer m.lockSearchUsingAttribute.Unlock()

	return len(m.calls.SearchUsingAttribute) > 0
}

// SearchUsingAttributeCalls returns the calls made to SearchUsingAttribute.
func (m *DefaultApi) SearchUsingAttributeCalls() []struct {
	Ctx               context.Context
	LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.SearchUsingAttributeOpts
} {
	m.lockSearchUsingAttribute.Lock()
	defer m.lockSearchUsingAttribute.Unlock()

	return m.calls.SearchUsingAttribute
}

// SearchUsingBasic mocks base method by wrapping the associated func.
func (m *DefaultApi) SearchUsingBasic(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.SearchUsingBasicOpts) (github_com_confluentinc_schema_registry_sdk_go.SearchResult, *net_http.Response, error) {
	m.lockSearchUsingBasic.Lock()
	defer m.lockSearchUsingBasic.Unlock()

	if m.SearchUsingBasicFunc == nil {
		panic("mocker: DefaultApi.SearchUsingBasicFunc is nil but DefaultApi.SearchUsingBasic was called.")
	}

	call := struct {
		Ctx               context.Context
		LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.SearchUsingBasicOpts
	}{
		Ctx:               ctx,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.SearchUsingBasic = append(m.calls.SearchUsingBasic, call)

	return m.SearchUsingBasicFunc(ctx, localVarOptionals)
}

// SearchUsingBasicCalled returns true if SearchUsingBasic was called at least once.
func (m *DefaultApi) SearchUsingBasicCalled() bool {
	m.lockSearchUsingBasic.Lock()
	defer m.lockSearchUsingBasic.Unlock()

	return len(m.calls.SearchUsingBasic) > 0
}

// SearchUsingBasicCalls returns the calls made to SearchUsingBasic.
func (m *DefaultApi) SearchUsingBasicCalls() []struct {
	Ctx               context.Context
	LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.SearchUsingBasicOpts
} {
	m.lockSearchUsingBasic.Lock()
	defer m.lockSearchUsingBasic.Unlock()

	return m.calls.SearchUsingBasic
}

// TestCompatibilityBySubjectName mocks base method by wrapping the associated func.
func (m *DefaultApi) TestCompatibilityBySubjectName(ctx context.Context, subject, version string, body github_com_confluentinc_schema_registry_sdk_go.RegisterSchemaRequest, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.TestCompatibilityBySubjectNameOpts) (github_com_confluentinc_schema_registry_sdk_go.CompatibilityCheckResponse, *net_http.Response, error) {
	m.lockTestCompatibilityBySubjectName.Lock()
	defer m.lockTestCompatibilityBySubjectName.Unlock()

	if m.TestCompatibilityBySubjectNameFunc == nil {
		panic("mocker: DefaultApi.TestCompatibilityBySubjectNameFunc is nil but DefaultApi.TestCompatibilityBySubjectName was called.")
	}

	call := struct {
		Ctx               context.Context
		Subject           string
		Version           string
		Body              github_com_confluentinc_schema_registry_sdk_go.RegisterSchemaRequest
		LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.TestCompatibilityBySubjectNameOpts
	}{
		Ctx:               ctx,
		Subject:           subject,
		Version:           version,
		Body:              body,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.TestCompatibilityBySubjectName = append(m.calls.TestCompatibilityBySubjectName, call)

	return m.TestCompatibilityBySubjectNameFunc(ctx, subject, version, body, localVarOptionals)
}

// TestCompatibilityBySubjectNameCalled returns true if TestCompatibilityBySubjectName was called at least once.
func (m *DefaultApi) TestCompatibilityBySubjectNameCalled() bool {
	m.lockTestCompatibilityBySubjectName.Lock()
	defer m.lockTestCompatibilityBySubjectName.Unlock()

	return len(m.calls.TestCompatibilityBySubjectName) > 0
}

// TestCompatibilityBySubjectNameCalls returns the calls made to TestCompatibilityBySubjectName.
func (m *DefaultApi) TestCompatibilityBySubjectNameCalls() []struct {
	Ctx               context.Context
	Subject           string
	Version           string
	Body              github_com_confluentinc_schema_registry_sdk_go.RegisterSchemaRequest
	LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.TestCompatibilityBySubjectNameOpts
} {
	m.lockTestCompatibilityBySubjectName.Lock()
	defer m.lockTestCompatibilityBySubjectName.Unlock()

	return m.calls.TestCompatibilityBySubjectName
}

// TestCompatibilityForSubject mocks base method by wrapping the associated func.
func (m *DefaultApi) TestCompatibilityForSubject(ctx context.Context, subject string, body github_com_confluentinc_schema_registry_sdk_go.RegisterSchemaRequest, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.TestCompatibilityForSubjectOpts) (github_com_confluentinc_schema_registry_sdk_go.CompatibilityCheckResponse, *net_http.Response, error) {
	m.lockTestCompatibilityForSubject.Lock()
	defer m.lockTestCompatibilityForSubject.Unlock()

	if m.TestCompatibilityForSubjectFunc == nil {
		panic("mocker: DefaultApi.TestCompatibilityForSubjectFunc is nil but DefaultApi.TestCompatibilityForSubject was called.")
	}

	call := struct {
		Ctx               context.Context
		Subject           string
		Body              github_com_confluentinc_schema_registry_sdk_go.RegisterSchemaRequest
		LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.TestCompatibilityForSubjectOpts
	}{
		Ctx:               ctx,
		Subject:           subject,
		Body:              body,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.TestCompatibilityForSubject = append(m.calls.TestCompatibilityForSubject, call)

	return m.TestCompatibilityForSubjectFunc(ctx, subject, body, localVarOptionals)
}

// TestCompatibilityForSubjectCalled returns true if TestCompatibilityForSubject was called at least once.
func (m *DefaultApi) TestCompatibilityForSubjectCalled() bool {
	m.lockTestCompatibilityForSubject.Lock()
	defer m.lockTestCompatibilityForSubject.Unlock()

	return len(m.calls.TestCompatibilityForSubject) > 0
}

// TestCompatibilityForSubjectCalls returns the calls made to TestCompatibilityForSubject.
func (m *DefaultApi) TestCompatibilityForSubjectCalls() []struct {
	Ctx               context.Context
	Subject           string
	Body              github_com_confluentinc_schema_registry_sdk_go.RegisterSchemaRequest
	LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.TestCompatibilityForSubjectOpts
} {
	m.lockTestCompatibilityForSubject.Lock()
	defer m.lockTestCompatibilityForSubject.Unlock()

	return m.calls.TestCompatibilityForSubject
}

// UpdateBusinessMetadata mocks base method by wrapping the associated func.
func (m *DefaultApi) UpdateBusinessMetadata(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.UpdateBusinessMetadataOpts) ([]github_com_confluentinc_schema_registry_sdk_go.BusinessMetadataResponse, *net_http.Response, error) {
	m.lockUpdateBusinessMetadata.Lock()
	defer m.lockUpdateBusinessMetadata.Unlock()

	if m.UpdateBusinessMetadataFunc == nil {
		panic("mocker: DefaultApi.UpdateBusinessMetadataFunc is nil but DefaultApi.UpdateBusinessMetadata was called.")
	}

	call := struct {
		Ctx               context.Context
		LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.UpdateBusinessMetadataOpts
	}{
		Ctx:               ctx,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.UpdateBusinessMetadata = append(m.calls.UpdateBusinessMetadata, call)

	return m.UpdateBusinessMetadataFunc(ctx, localVarOptionals)
}

// UpdateBusinessMetadataCalled returns true if UpdateBusinessMetadata was called at least once.
func (m *DefaultApi) UpdateBusinessMetadataCalled() bool {
	m.lockUpdateBusinessMetadata.Lock()
	defer m.lockUpdateBusinessMetadata.Unlock()

	return len(m.calls.UpdateBusinessMetadata) > 0
}

// UpdateBusinessMetadataCalls returns the calls made to UpdateBusinessMetadata.
func (m *DefaultApi) UpdateBusinessMetadataCalls() []struct {
	Ctx               context.Context
	LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.UpdateBusinessMetadataOpts
} {
	m.lockUpdateBusinessMetadata.Lock()
	defer m.lockUpdateBusinessMetadata.Unlock()

	return m.calls.UpdateBusinessMetadata
}

// UpdateBusinessMetadataDefs mocks base method by wrapping the associated func.
func (m *DefaultApi) UpdateBusinessMetadataDefs(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.UpdateBusinessMetadataDefsOpts) ([]github_com_confluentinc_schema_registry_sdk_go.BusinessMetadataDefResponse, *net_http.Response, error) {
	m.lockUpdateBusinessMetadataDefs.Lock()
	defer m.lockUpdateBusinessMetadataDefs.Unlock()

	if m.UpdateBusinessMetadataDefsFunc == nil {
		panic("mocker: DefaultApi.UpdateBusinessMetadataDefsFunc is nil but DefaultApi.UpdateBusinessMetadataDefs was called.")
	}

	call := struct {
		Ctx               context.Context
		LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.UpdateBusinessMetadataDefsOpts
	}{
		Ctx:               ctx,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.UpdateBusinessMetadataDefs = append(m.calls.UpdateBusinessMetadataDefs, call)

	return m.UpdateBusinessMetadataDefsFunc(ctx, localVarOptionals)
}

// UpdateBusinessMetadataDefsCalled returns true if UpdateBusinessMetadataDefs was called at least once.
func (m *DefaultApi) UpdateBusinessMetadataDefsCalled() bool {
	m.lockUpdateBusinessMetadataDefs.Lock()
	defer m.lockUpdateBusinessMetadataDefs.Unlock()

	return len(m.calls.UpdateBusinessMetadataDefs) > 0
}

// UpdateBusinessMetadataDefsCalls returns the calls made to UpdateBusinessMetadataDefs.
func (m *DefaultApi) UpdateBusinessMetadataDefsCalls() []struct {
	Ctx               context.Context
	LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.UpdateBusinessMetadataDefsOpts
} {
	m.lockUpdateBusinessMetadataDefs.Lock()
	defer m.lockUpdateBusinessMetadataDefs.Unlock()

	return m.calls.UpdateBusinessMetadataDefs
}

// UpdateMode mocks base method by wrapping the associated func.
func (m *DefaultApi) UpdateMode(ctx context.Context, subject string, body github_com_confluentinc_schema_registry_sdk_go.ModeUpdateRequest) (github_com_confluentinc_schema_registry_sdk_go.ModeUpdateRequest, *net_http.Response, error) {
	m.lockUpdateMode.Lock()
	defer m.lockUpdateMode.Unlock()

	if m.UpdateModeFunc == nil {
		panic("mocker: DefaultApi.UpdateModeFunc is nil but DefaultApi.UpdateMode was called.")
	}

	call := struct {
		Ctx     context.Context
		Subject string
		Body    github_com_confluentinc_schema_registry_sdk_go.ModeUpdateRequest
	}{
		Ctx:     ctx,
		Subject: subject,
		Body:    body,
	}

	m.calls.UpdateMode = append(m.calls.UpdateMode, call)

	return m.UpdateModeFunc(ctx, subject, body)
}

// UpdateModeCalled returns true if UpdateMode was called at least once.
func (m *DefaultApi) UpdateModeCalled() bool {
	m.lockUpdateMode.Lock()
	defer m.lockUpdateMode.Unlock()

	return len(m.calls.UpdateMode) > 0
}

// UpdateModeCalls returns the calls made to UpdateMode.
func (m *DefaultApi) UpdateModeCalls() []struct {
	Ctx     context.Context
	Subject string
	Body    github_com_confluentinc_schema_registry_sdk_go.ModeUpdateRequest
} {
	m.lockUpdateMode.Lock()
	defer m.lockUpdateMode.Unlock()

	return m.calls.UpdateMode
}

// UpdateSubjectLevelConfig mocks base method by wrapping the associated func.
func (m *DefaultApi) UpdateSubjectLevelConfig(ctx context.Context, subject string, body github_com_confluentinc_schema_registry_sdk_go.ConfigUpdateRequest) (github_com_confluentinc_schema_registry_sdk_go.ConfigUpdateRequest, *net_http.Response, error) {
	m.lockUpdateSubjectLevelConfig.Lock()
	defer m.lockUpdateSubjectLevelConfig.Unlock()

	if m.UpdateSubjectLevelConfigFunc == nil {
		panic("mocker: DefaultApi.UpdateSubjectLevelConfigFunc is nil but DefaultApi.UpdateSubjectLevelConfig was called.")
	}

	call := struct {
		Ctx     context.Context
		Subject string
		Body    github_com_confluentinc_schema_registry_sdk_go.ConfigUpdateRequest
	}{
		Ctx:     ctx,
		Subject: subject,
		Body:    body,
	}

	m.calls.UpdateSubjectLevelConfig = append(m.calls.UpdateSubjectLevelConfig, call)

	return m.UpdateSubjectLevelConfigFunc(ctx, subject, body)
}

// UpdateSubjectLevelConfigCalled returns true if UpdateSubjectLevelConfig was called at least once.
func (m *DefaultApi) UpdateSubjectLevelConfigCalled() bool {
	m.lockUpdateSubjectLevelConfig.Lock()
	defer m.lockUpdateSubjectLevelConfig.Unlock()

	return len(m.calls.UpdateSubjectLevelConfig) > 0
}

// UpdateSubjectLevelConfigCalls returns the calls made to UpdateSubjectLevelConfig.
func (m *DefaultApi) UpdateSubjectLevelConfigCalls() []struct {
	Ctx     context.Context
	Subject string
	Body    github_com_confluentinc_schema_registry_sdk_go.ConfigUpdateRequest
} {
	m.lockUpdateSubjectLevelConfig.Lock()
	defer m.lockUpdateSubjectLevelConfig.Unlock()

	return m.calls.UpdateSubjectLevelConfig
}

// UpdateTagDefs mocks base method by wrapping the associated func.
func (m *DefaultApi) UpdateTagDefs(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.UpdateTagDefsOpts) ([]github_com_confluentinc_schema_registry_sdk_go.TagDefResponse, *net_http.Response, error) {
	m.lockUpdateTagDefs.Lock()
	defer m.lockUpdateTagDefs.Unlock()

	if m.UpdateTagDefsFunc == nil {
		panic("mocker: DefaultApi.UpdateTagDefsFunc is nil but DefaultApi.UpdateTagDefs was called.")
	}

	call := struct {
		Ctx               context.Context
		LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.UpdateTagDefsOpts
	}{
		Ctx:               ctx,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.UpdateTagDefs = append(m.calls.UpdateTagDefs, call)

	return m.UpdateTagDefsFunc(ctx, localVarOptionals)
}

// UpdateTagDefsCalled returns true if UpdateTagDefs was called at least once.
func (m *DefaultApi) UpdateTagDefsCalled() bool {
	m.lockUpdateTagDefs.Lock()
	defer m.lockUpdateTagDefs.Unlock()

	return len(m.calls.UpdateTagDefs) > 0
}

// UpdateTagDefsCalls returns the calls made to UpdateTagDefs.
func (m *DefaultApi) UpdateTagDefsCalls() []struct {
	Ctx               context.Context
	LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.UpdateTagDefsOpts
} {
	m.lockUpdateTagDefs.Lock()
	defer m.lockUpdateTagDefs.Unlock()

	return m.calls.UpdateTagDefs
}

// UpdateTags mocks base method by wrapping the associated func.
func (m *DefaultApi) UpdateTags(ctx context.Context, localVarOptionals *github_com_confluentinc_schema_registry_sdk_go.UpdateTagsOpts) ([]github_com_confluentinc_schema_registry_sdk_go.TagResponse, *net_http.Response, error) {
	m.lockUpdateTags.Lock()
	defer m.lockUpdateTags.Unlock()

	if m.UpdateTagsFunc == nil {
		panic("mocker: DefaultApi.UpdateTagsFunc is nil but DefaultApi.UpdateTags was called.")
	}

	call := struct {
		Ctx               context.Context
		LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.UpdateTagsOpts
	}{
		Ctx:               ctx,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.UpdateTags = append(m.calls.UpdateTags, call)

	return m.UpdateTagsFunc(ctx, localVarOptionals)
}

// UpdateTagsCalled returns true if UpdateTags was called at least once.
func (m *DefaultApi) UpdateTagsCalled() bool {
	m.lockUpdateTags.Lock()
	defer m.lockUpdateTags.Unlock()

	return len(m.calls.UpdateTags) > 0
}

// UpdateTagsCalls returns the calls made to UpdateTags.
func (m *DefaultApi) UpdateTagsCalls() []struct {
	Ctx               context.Context
	LocalVarOptionals *github_com_confluentinc_schema_registry_sdk_go.UpdateTagsOpts
} {
	m.lockUpdateTags.Lock()
	defer m.lockUpdateTags.Unlock()

	return m.calls.UpdateTags
}

// UpdateTopLevelConfig mocks base method by wrapping the associated func.
func (m *DefaultApi) UpdateTopLevelConfig(ctx context.Context, body github_com_confluentinc_schema_registry_sdk_go.ConfigUpdateRequest) (github_com_confluentinc_schema_registry_sdk_go.ConfigUpdateRequest, *net_http.Response, error) {
	m.lockUpdateTopLevelConfig.Lock()
	defer m.lockUpdateTopLevelConfig.Unlock()

	if m.UpdateTopLevelConfigFunc == nil {
		panic("mocker: DefaultApi.UpdateTopLevelConfigFunc is nil but DefaultApi.UpdateTopLevelConfig was called.")
	}

	call := struct {
		Ctx  context.Context
		Body github_com_confluentinc_schema_registry_sdk_go.ConfigUpdateRequest
	}{
		Ctx:  ctx,
		Body: body,
	}

	m.calls.UpdateTopLevelConfig = append(m.calls.UpdateTopLevelConfig, call)

	return m.UpdateTopLevelConfigFunc(ctx, body)
}

// UpdateTopLevelConfigCalled returns true if UpdateTopLevelConfig was called at least once.
func (m *DefaultApi) UpdateTopLevelConfigCalled() bool {
	m.lockUpdateTopLevelConfig.Lock()
	defer m.lockUpdateTopLevelConfig.Unlock()

	return len(m.calls.UpdateTopLevelConfig) > 0
}

// UpdateTopLevelConfigCalls returns the calls made to UpdateTopLevelConfig.
func (m *DefaultApi) UpdateTopLevelConfigCalls() []struct {
	Ctx  context.Context
	Body github_com_confluentinc_schema_registry_sdk_go.ConfigUpdateRequest
} {
	m.lockUpdateTopLevelConfig.Lock()
	defer m.lockUpdateTopLevelConfig.Unlock()

	return m.calls.UpdateTopLevelConfig
}

// UpdateTopLevelMode mocks base method by wrapping the associated func.
func (m *DefaultApi) UpdateTopLevelMode(ctx context.Context, body github_com_confluentinc_schema_registry_sdk_go.ModeUpdateRequest) (github_com_confluentinc_schema_registry_sdk_go.ModeUpdateRequest, *net_http.Response, error) {
	m.lockUpdateTopLevelMode.Lock()
	defer m.lockUpdateTopLevelMode.Unlock()

	if m.UpdateTopLevelModeFunc == nil {
		panic("mocker: DefaultApi.UpdateTopLevelModeFunc is nil but DefaultApi.UpdateTopLevelMode was called.")
	}

	call := struct {
		Ctx  context.Context
		Body github_com_confluentinc_schema_registry_sdk_go.ModeUpdateRequest
	}{
		Ctx:  ctx,
		Body: body,
	}

	m.calls.UpdateTopLevelMode = append(m.calls.UpdateTopLevelMode, call)

	return m.UpdateTopLevelModeFunc(ctx, body)
}

// UpdateTopLevelModeCalled returns true if UpdateTopLevelMode was called at least once.
func (m *DefaultApi) UpdateTopLevelModeCalled() bool {
	m.lockUpdateTopLevelMode.Lock()
	defer m.lockUpdateTopLevelMode.Unlock()

	return len(m.calls.UpdateTopLevelMode) > 0
}

// UpdateTopLevelModeCalls returns the calls made to UpdateTopLevelMode.
func (m *DefaultApi) UpdateTopLevelModeCalls() []struct {
	Ctx  context.Context
	Body github_com_confluentinc_schema_registry_sdk_go.ModeUpdateRequest
} {
	m.lockUpdateTopLevelMode.Lock()
	defer m.lockUpdateTopLevelMode.Unlock()

	return m.calls.UpdateTopLevelMode
}

// Reset resets the calls made to the mocked methods.
func (m *DefaultApi) Reset() {
	m.lockAsyncapiPut.Lock()
	m.calls.AsyncapiPut = nil
	m.lockAsyncapiPut.Unlock()
	m.lockCreateBusinessMetadata.Lock()
	m.calls.CreateBusinessMetadata = nil
	m.lockCreateBusinessMetadata.Unlock()
	m.lockCreateBusinessMetadataDefs.Lock()
	m.calls.CreateBusinessMetadataDefs = nil
	m.lockCreateBusinessMetadataDefs.Unlock()
	m.lockCreateExporter.Lock()
	m.calls.CreateExporter = nil
	m.lockCreateExporter.Unlock()
	m.lockCreateOrUpdate.Lock()
	m.calls.CreateOrUpdate = nil
	m.lockCreateOrUpdate.Unlock()
	m.lockCreateTagDefs.Lock()
	m.calls.CreateTagDefs = nil
	m.lockCreateTagDefs.Unlock()
	m.lockCreateTags.Lock()
	m.calls.CreateTags = nil
	m.lockCreateTags.Unlock()
	m.lockDeleteBusinessMetadata.Lock()
	m.calls.DeleteBusinessMetadata = nil
	m.lockDeleteBusinessMetadata.Unlock()
	m.lockDeleteBusinessMetadataDef.Lock()
	m.calls.DeleteBusinessMetadataDef = nil
	m.lockDeleteBusinessMetadataDef.Unlock()
	m.lockDeleteByUniqueAttributes.Lock()
	m.calls.DeleteByUniqueAttributes = nil
	m.lockDeleteByUniqueAttributes.Unlock()
	m.lockDeleteExporter.Lock()
	m.calls.DeleteExporter = nil
	m.lockDeleteExporter.Unlock()
	m.lockDeleteSchemaVersion.Lock()
	m.calls.DeleteSchemaVersion = nil
	m.lockDeleteSchemaVersion.Unlock()
	m.lockDeleteSubject.Lock()
	m.calls.DeleteSubject = nil
	m.lockDeleteSubject.Unlock()
	m.lockDeleteSubjectConfig.Lock()
	m.calls.DeleteSubjectConfig = nil
	m.lockDeleteSubjectConfig.Unlock()
	m.lockDeleteSubjectMode.Lock()
	m.calls.DeleteSubjectMode = nil
	m.lockDeleteSubjectMode.Unlock()
	m.lockDeleteTag.Lock()
	m.calls.DeleteTag = nil
	m.lockDeleteTag.Unlock()
	m.lockDeleteTagDef.Lock()
	m.calls.DeleteTagDef = nil
	m.lockDeleteTagDef.Unlock()
	m.lockGet.Lock()
	m.calls.Get = nil
	m.lockGet.Unlock()
	m.lockGetAllBusinessMetadataDefs.Lock()
	m.calls.GetAllBusinessMetadataDefs = nil
	m.lockGetAllBusinessMetadataDefs.Unlock()
	m.lockGetAllTagDefs.Lock()
	m.calls.GetAllTagDefs = nil
	m.lockGetAllTagDefs.Unlock()
	m.lockGetBusinessMetadata.Lock()
	m.calls.GetBusinessMetadata = nil
	m.lockGetBusinessMetadata.Unlock()
	m.lockGetBusinessMetadataDefByName.Lock()
	m.calls.GetBusinessMetadataDefByName = nil
	m.lockGetBusinessMetadataDefByName.Unlock()
	m.lockGetByUniqueAttributes.Lock()
	m.calls.GetByUniqueAttributes = nil
	m.lockGetByUniqueAttributes.Unlock()
	m.lockGetClusterId.Lock()
	m.calls.GetClusterId = nil
	m.lockGetClusterId.Unlock()
	m.lockGetExporterConfig.Lock()
	m.calls.GetExporterConfig = nil
	m.lockGetExporterConfig.Unlock()
	m.lockGetExporterInfo.Lock()
	m.calls.GetExporterInfo = nil
	m.lockGetExporterInfo.Unlock()
	m.lockGetExporterStatus.Lock()
	m.calls.GetExporterStatus = nil
	m.lockGetExporterStatus.Unlock()
	m.lockGetExporters.Lock()
	m.calls.GetExporters = nil
	m.lockGetExporters.Unlock()
	m.lockGetMode.Lock()
	m.calls.GetMode = nil
	m.lockGetMode.Unlock()
	m.lockGetReferencedBy.Lock()
	m.calls.GetReferencedBy = nil
	m.lockGetReferencedBy.Unlock()
	m.lockGetSchema.Lock()
	m.calls.GetSchema = nil
	m.lockGetSchema.Unlock()
	m.lockGetSchemaByVersion.Lock()
	m.calls.GetSchemaByVersion = nil
	m.lockGetSchemaByVersion.Unlock()
	m.lockGetSchemaOnly.Lock()
	m.calls.GetSchemaOnly = nil
	m.lockGetSchemaOnly.Unlock()
	m.lockGetSchemaTypes.Lock()
	m.calls.GetSchemaTypes = nil
	m.lockGetSchemaTypes.Unlock()
	m.lockGetSchemas.Lock()
	m.calls.GetSchemas = nil
	m.lockGetSchemas.Unlock()
	m.lockGetSubjectLevelConfig.Lock()
	m.calls.GetSubjectLevelConfig = nil
	m.lockGetSubjectLevelConfig.Unlock()
	m.lockGetSubjects.Lock()
	m.calls.GetSubjects = nil
	m.lockGetSubjects.Unlock()
	m.lockGetTagDefByName.Lock()
	m.calls.GetTagDefByName = nil
	m.lockGetTagDefByName.Unlock()
	m.lockGetTags.Lock()
	m.calls.GetTags = nil
	m.lockGetTags.Unlock()
	m.lockGetTopLevelConfig.Lock()
	m.calls.GetTopLevelConfig = nil
	m.lockGetTopLevelConfig.Unlock()
	m.lockGetTopLevelMode.Lock()
	m.calls.GetTopLevelMode = nil
	m.lockGetTopLevelMode.Unlock()
	m.lockGetVersions.Lock()
	m.calls.GetVersions = nil
	m.lockGetVersions.Unlock()
	m.lockList.Lock()
	m.calls.List = nil
	m.lockList.Unlock()
	m.lockListContexts.Lock()
	m.calls.ListContexts = nil
	m.lockListContexts.Unlock()
	m.lockListVersions.Lock()
	m.calls.ListVersions = nil
	m.lockListVersions.Unlock()
	m.lockLookUpSchemaUnderSubject.Lock()
	m.calls.LookUpSchemaUnderSubject = nil
	m.lockLookUpSchemaUnderSubject.Unlock()
	m.lockPartialUpdateByUniqueAttributes.Lock()
	m.calls.PartialUpdateByUniqueAttributes = nil
	m.lockPartialUpdateByUniqueAttributes.Unlock()
	m.lockPauseExporter.Lock()
	m.calls.PauseExporter = nil
	m.lockPauseExporter.Unlock()
	m.lockPost.Lock()
	m.calls.Post = nil
	m.lockPost.Unlock()
	m.lockPutExporter.Lock()
	m.calls.PutExporter = nil
	m.lockPutExporter.Unlock()
	m.lockPutExporterConfig.Lock()
	m.calls.PutExporterConfig = nil
	m.lockPutExporterConfig.Unlock()
	m.lockRegister.Lock()
	m.calls.Register = nil
	m.lockRegister.Unlock()
	m.lockResetExporter.Lock()
	m.calls.ResetExporter = nil
	m.lockResetExporter.Unlock()
	m.lockResumeExporter.Lock()
	m.calls.ResumeExporter = nil
	m.lockResumeExporter.Unlock()
	m.lockSearchUsingAttribute.Lock()
	m.calls.SearchUsingAttribute = nil
	m.lockSearchUsingAttribute.Unlock()
	m.lockSearchUsingBasic.Lock()
	m.calls.SearchUsingBasic = nil
	m.lockSearchUsingBasic.Unlock()
	m.lockTestCompatibilityBySubjectName.Lock()
	m.calls.TestCompatibilityBySubjectName = nil
	m.lockTestCompatibilityBySubjectName.Unlock()
	m.lockTestCompatibilityForSubject.Lock()
	m.calls.TestCompatibilityForSubject = nil
	m.lockTestCompatibilityForSubject.Unlock()
	m.lockUpdateBusinessMetadata.Lock()
	m.calls.UpdateBusinessMetadata = nil
	m.lockUpdateBusinessMetadata.Unlock()
	m.lockUpdateBusinessMetadataDefs.Lock()
	m.calls.UpdateBusinessMetadataDefs = nil
	m.lockUpdateBusinessMetadataDefs.Unlock()
	m.lockUpdateMode.Lock()
	m.calls.UpdateMode = nil
	m.lockUpdateMode.Unlock()
	m.lockUpdateSubjectLevelConfig.Lock()
	m.calls.UpdateSubjectLevelConfig = nil
	m.lockUpdateSubjectLevelConfig.Unlock()
	m.lockUpdateTagDefs.Lock()
	m.calls.UpdateTagDefs = nil
	m.lockUpdateTagDefs.Unlock()
	m.lockUpdateTags.Lock()
	m.calls.UpdateTags = nil
	m.lockUpdateTags.Unlock()
	m.lockUpdateTopLevelConfig.Lock()
	m.calls.UpdateTopLevelConfig = nil
	m.lockUpdateTopLevelConfig.Unlock()
	m.lockUpdateTopLevelMode.Lock()
	m.calls.UpdateTopLevelMode = nil
	m.lockUpdateTopLevelMode.Unlock()
}
