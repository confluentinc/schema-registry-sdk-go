// Code generated by mocker. DO NOT EDIT.
// github.com/travisjeffery/mocker
// Source: api_default.go

package mock

import (
	context "context"
	net_http "net/http"
	sync "sync"

	api_default_go "api_default.go"
)

// DefaultApi is a mock of DefaultApi interface
type DefaultApi struct {
	lockDeleteSchemaVersion sync.Mutex
	DeleteSchemaVersionFunc func(ctx context.Context, subject, version string, localVarOptionals *api_default_go.DeleteSchemaVersionOpts) (int32, *net_http.Response, error)

	lockDeleteSubject sync.Mutex
	DeleteSubjectFunc func(ctx context.Context, subject string, localVarOptionals *api_default_go.DeleteSubjectOpts) ([]int32, *net_http.Response, error)

	lockGet sync.Mutex
	GetFunc func(ctx context.Context) (map[string]map[string]interface{}, *net_http.Response, error)

	lockGetClusterId sync.Mutex
	GetClusterIdFunc func(ctx context.Context) (api_default_go.ServerClusterId, *net_http.Response, error)

	lockGetMode sync.Mutex
	GetModeFunc func(ctx context.Context, subject string) (api_default_go.ModeGetResponse, *net_http.Response, error)

	lockGetReferencedBy sync.Mutex
	GetReferencedByFunc func(ctx context.Context, subject, version string) ([]int32, *net_http.Response, error)

	lockGetSchema sync.Mutex
	GetSchemaFunc func(ctx context.Context, id int32, localVarOptionals *api_default_go.GetSchemaOpts) (api_default_go.SchemaString, *net_http.Response, error)

	lockGetSchemaByVersion sync.Mutex
	GetSchemaByVersionFunc func(ctx context.Context, subject, version string, localVarOptionals *api_default_go.GetSchemaByVersionOpts) (api_default_go.Schema, *net_http.Response, error)

	lockGetSchemaOnly sync.Mutex
	GetSchemaOnlyFunc func(ctx context.Context, subject, version string, localVarOptionals *api_default_go.GetSchemaOnlyOpts) (string, *net_http.Response, error)

	lockGetSchemaTypes sync.Mutex
	GetSchemaTypesFunc func(ctx context.Context) ([]string, *net_http.Response, error)

	lockGetSubjectLevelConfig sync.Mutex
	GetSubjectLevelConfigFunc func(ctx context.Context, subject string, localVarOptionals *api_default_go.GetSubjectLevelConfigOpts) (api_default_go.Config, *net_http.Response, error)

	lockGetSubjects sync.Mutex
	GetSubjectsFunc func(ctx context.Context, id int32) ([]string, *net_http.Response, error)

	lockGetTopLevelConfig sync.Mutex
	GetTopLevelConfigFunc func(ctx context.Context) (api_default_go.Config, *net_http.Response, error)

	lockGetTopLevelMode sync.Mutex
	GetTopLevelModeFunc func(ctx context.Context) (api_default_go.ModeGetResponse, *net_http.Response, error)

	lockGetVersions sync.Mutex
	GetVersionsFunc func(ctx context.Context, id int32) ([]api_default_go.SubjectVersion, *net_http.Response, error)

	lockList sync.Mutex
	ListFunc func(ctx context.Context, localVarOptionals *api_default_go.ListOpts) ([]string, *net_http.Response, error)

	lockListVersions sync.Mutex
	ListVersionsFunc func(ctx context.Context, subject string, localVarOptionals *api_default_go.ListVersionsOpts) ([]int32, *net_http.Response, error)

	lockLookUpSchemaUnderSubject sync.Mutex
	LookUpSchemaUnderSubjectFunc func(ctx context.Context, subject string, body api_default_go.RegisterSchemaRequest, localVarOptionals *api_default_go.LookUpSchemaUnderSubjectOpts) (*net_http.Response, error)

	lockPost sync.Mutex
	PostFunc func(ctx context.Context) (map[string]string, *net_http.Response, error)

	lockRegister sync.Mutex
	RegisterFunc func(ctx context.Context, subject string, body api_default_go.RegisterSchemaRequest) (api_default_go.RegisterSchemaResponse, *net_http.Response, error)

	lockTestCompatibilityBySubjectName sync.Mutex
	TestCompatibilityBySubjectNameFunc func(ctx context.Context, subject, version string, body api_default_go.RegisterSchemaRequest, localVarOptionals *api_default_go.TestCompatibilityBySubjectNameOpts) (api_default_go.CompatibilityCheckResponse, *net_http.Response, error)

	lockUpdateMode sync.Mutex
	UpdateModeFunc func(ctx context.Context, subject string, body api_default_go.ModeUpdateRequest) (api_default_go.ModeUpdateRequest, *net_http.Response, error)

	lockUpdateSubjectLevelConfig sync.Mutex
	UpdateSubjectLevelConfigFunc func(ctx context.Context, subject string, body api_default_go.ConfigUpdateRequest) (api_default_go.ConfigUpdateRequest, *net_http.Response, error)

	lockUpdateTopLevelConfig sync.Mutex
	UpdateTopLevelConfigFunc func(ctx context.Context, body api_default_go.ConfigUpdateRequest) (api_default_go.ConfigUpdateRequest, *net_http.Response, error)

	lockUpdateTopLevelMode sync.Mutex
	UpdateTopLevelModeFunc func(ctx context.Context, body api_default_go.ModeUpdateRequest) (api_default_go.ModeUpdateRequest, *net_http.Response, error)

	calls struct {
		DeleteSchemaVersion []struct {
			Ctx               context.Context
			Subject           string
			Version           string
			LocalVarOptionals *api_default_go.DeleteSchemaVersionOpts
		}
		DeleteSubject []struct {
			Ctx               context.Context
			Subject           string
			LocalVarOptionals *api_default_go.DeleteSubjectOpts
		}
		Get []struct {
			Ctx context.Context
		}
		GetClusterId []struct {
			Ctx context.Context
		}
		GetMode []struct {
			Ctx     context.Context
			Subject string
		}
		GetReferencedBy []struct {
			Ctx     context.Context
			Subject string
			Version string
		}
		GetSchema []struct {
			Ctx               context.Context
			Id                int32
			LocalVarOptionals *api_default_go.GetSchemaOpts
		}
		GetSchemaByVersion []struct {
			Ctx               context.Context
			Subject           string
			Version           string
			LocalVarOptionals *api_default_go.GetSchemaByVersionOpts
		}
		GetSchemaOnly []struct {
			Ctx               context.Context
			Subject           string
			Version           string
			LocalVarOptionals *api_default_go.GetSchemaOnlyOpts
		}
		GetSchemaTypes []struct {
			Ctx context.Context
		}
		GetSubjectLevelConfig []struct {
			Ctx               context.Context
			Subject           string
			LocalVarOptionals *api_default_go.GetSubjectLevelConfigOpts
		}
		GetSubjects []struct {
			Ctx context.Context
			Id  int32
		}
		GetTopLevelConfig []struct {
			Ctx context.Context
		}
		GetTopLevelMode []struct {
			Ctx context.Context
		}
		GetVersions []struct {
			Ctx context.Context
			Id  int32
		}
		List []struct {
			Ctx               context.Context
			LocalVarOptionals *api_default_go.ListOpts
		}
		ListVersions []struct {
			Ctx               context.Context
			Subject           string
			LocalVarOptionals *api_default_go.ListVersionsOpts
		}
		LookUpSchemaUnderSubject []struct {
			Ctx               context.Context
			Subject           string
			Body              api_default_go.RegisterSchemaRequest
			LocalVarOptionals *api_default_go.LookUpSchemaUnderSubjectOpts
		}
		Post []struct {
			Ctx context.Context
		}
		Register []struct {
			Ctx     context.Context
			Subject string
			Body    api_default_go.RegisterSchemaRequest
		}
		TestCompatibilityBySubjectName []struct {
			Ctx               context.Context
			Subject           string
			Version           string
			Body              api_default_go.RegisterSchemaRequest
			LocalVarOptionals *api_default_go.TestCompatibilityBySubjectNameOpts
		}
		UpdateMode []struct {
			Ctx     context.Context
			Subject string
			Body    api_default_go.ModeUpdateRequest
		}
		UpdateSubjectLevelConfig []struct {
			Ctx     context.Context
			Subject string
			Body    api_default_go.ConfigUpdateRequest
		}
		UpdateTopLevelConfig []struct {
			Ctx  context.Context
			Body api_default_go.ConfigUpdateRequest
		}
		UpdateTopLevelMode []struct {
			Ctx  context.Context
			Body api_default_go.ModeUpdateRequest
		}
	}
}

// DeleteSchemaVersion mocks base method by wrapping the associated func.
func (m *DefaultApi) DeleteSchemaVersion(ctx context.Context, subject, version string, localVarOptionals *api_default_go.DeleteSchemaVersionOpts) (int32, *net_http.Response, error) {
	m.lockDeleteSchemaVersion.Lock()
	defer m.lockDeleteSchemaVersion.Unlock()

	if m.DeleteSchemaVersionFunc == nil {
		panic("mocker: DefaultApi.DeleteSchemaVersionFunc is nil but DefaultApi.DeleteSchemaVersion was called.")
	}

	call := struct {
		Ctx               context.Context
		Subject           string
		Version           string
		LocalVarOptionals *api_default_go.DeleteSchemaVersionOpts
	}{
		Ctx:               ctx,
		Subject:           subject,
		Version:           version,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.DeleteSchemaVersion = append(m.calls.DeleteSchemaVersion, call)

	return m.DeleteSchemaVersionFunc(ctx, subject, version, localVarOptionals)
}

// DeleteSchemaVersionCalled returns true if DeleteSchemaVersion was called at least once.
func (m *DefaultApi) DeleteSchemaVersionCalled() bool {
	m.lockDeleteSchemaVersion.Lock()
	defer m.lockDeleteSchemaVersion.Unlock()

	return len(m.calls.DeleteSchemaVersion) > 0
}

// DeleteSchemaVersionCalls returns the calls made to DeleteSchemaVersion.
func (m *DefaultApi) DeleteSchemaVersionCalls() []struct {
	Ctx               context.Context
	Subject           string
	Version           string
	LocalVarOptionals *api_default_go.DeleteSchemaVersionOpts
} {
	m.lockDeleteSchemaVersion.Lock()
	defer m.lockDeleteSchemaVersion.Unlock()

	return m.calls.DeleteSchemaVersion
}

// DeleteSubject mocks base method by wrapping the associated func.
func (m *DefaultApi) DeleteSubject(ctx context.Context, subject string, localVarOptionals *api_default_go.DeleteSubjectOpts) ([]int32, *net_http.Response, error) {
	m.lockDeleteSubject.Lock()
	defer m.lockDeleteSubject.Unlock()

	if m.DeleteSubjectFunc == nil {
		panic("mocker: DefaultApi.DeleteSubjectFunc is nil but DefaultApi.DeleteSubject was called.")
	}

	call := struct {
		Ctx               context.Context
		Subject           string
		LocalVarOptionals *api_default_go.DeleteSubjectOpts
	}{
		Ctx:               ctx,
		Subject:           subject,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.DeleteSubject = append(m.calls.DeleteSubject, call)

	return m.DeleteSubjectFunc(ctx, subject, localVarOptionals)
}

// DeleteSubjectCalled returns true if DeleteSubject was called at least once.
func (m *DefaultApi) DeleteSubjectCalled() bool {
	m.lockDeleteSubject.Lock()
	defer m.lockDeleteSubject.Unlock()

	return len(m.calls.DeleteSubject) > 0
}

// DeleteSubjectCalls returns the calls made to DeleteSubject.
func (m *DefaultApi) DeleteSubjectCalls() []struct {
	Ctx               context.Context
	Subject           string
	LocalVarOptionals *api_default_go.DeleteSubjectOpts
} {
	m.lockDeleteSubject.Lock()
	defer m.lockDeleteSubject.Unlock()

	return m.calls.DeleteSubject
}

// Get mocks base method by wrapping the associated func.
func (m *DefaultApi) Get(ctx context.Context) (map[string]map[string]interface{}, *net_http.Response, error) {
	m.lockGet.Lock()
	defer m.lockGet.Unlock()

	if m.GetFunc == nil {
		panic("mocker: DefaultApi.GetFunc is nil but DefaultApi.Get was called.")
	}

	call := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}

	m.calls.Get = append(m.calls.Get, call)

	return m.GetFunc(ctx)
}

// GetCalled returns true if Get was called at least once.
func (m *DefaultApi) GetCalled() bool {
	m.lockGet.Lock()
	defer m.lockGet.Unlock()

	return len(m.calls.Get) > 0
}

// GetCalls returns the calls made to Get.
func (m *DefaultApi) GetCalls() []struct {
	Ctx context.Context
} {
	m.lockGet.Lock()
	defer m.lockGet.Unlock()

	return m.calls.Get
}

// GetClusterId mocks base method by wrapping the associated func.
func (m *DefaultApi) GetClusterId(ctx context.Context) (api_default_go.ServerClusterId, *net_http.Response, error) {
	m.lockGetClusterId.Lock()
	defer m.lockGetClusterId.Unlock()

	if m.GetClusterIdFunc == nil {
		panic("mocker: DefaultApi.GetClusterIdFunc is nil but DefaultApi.GetClusterId was called.")
	}

	call := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}

	m.calls.GetClusterId = append(m.calls.GetClusterId, call)

	return m.GetClusterIdFunc(ctx)
}

// GetClusterIdCalled returns true if GetClusterId was called at least once.
func (m *DefaultApi) GetClusterIdCalled() bool {
	m.lockGetClusterId.Lock()
	defer m.lockGetClusterId.Unlock()

	return len(m.calls.GetClusterId) > 0
}

// GetClusterIdCalls returns the calls made to GetClusterId.
func (m *DefaultApi) GetClusterIdCalls() []struct {
	Ctx context.Context
} {
	m.lockGetClusterId.Lock()
	defer m.lockGetClusterId.Unlock()

	return m.calls.GetClusterId
}

// GetMode mocks base method by wrapping the associated func.
func (m *DefaultApi) GetMode(ctx context.Context, subject string) (api_default_go.ModeGetResponse, *net_http.Response, error) {
	m.lockGetMode.Lock()
	defer m.lockGetMode.Unlock()

	if m.GetModeFunc == nil {
		panic("mocker: DefaultApi.GetModeFunc is nil but DefaultApi.GetMode was called.")
	}

	call := struct {
		Ctx     context.Context
		Subject string
	}{
		Ctx:     ctx,
		Subject: subject,
	}

	m.calls.GetMode = append(m.calls.GetMode, call)

	return m.GetModeFunc(ctx, subject)
}

// GetModeCalled returns true if GetMode was called at least once.
func (m *DefaultApi) GetModeCalled() bool {
	m.lockGetMode.Lock()
	defer m.lockGetMode.Unlock()

	return len(m.calls.GetMode) > 0
}

// GetModeCalls returns the calls made to GetMode.
func (m *DefaultApi) GetModeCalls() []struct {
	Ctx     context.Context
	Subject string
} {
	m.lockGetMode.Lock()
	defer m.lockGetMode.Unlock()

	return m.calls.GetMode
}

// GetReferencedBy mocks base method by wrapping the associated func.
func (m *DefaultApi) GetReferencedBy(ctx context.Context, subject, version string) ([]int32, *net_http.Response, error) {
	m.lockGetReferencedBy.Lock()
	defer m.lockGetReferencedBy.Unlock()

	if m.GetReferencedByFunc == nil {
		panic("mocker: DefaultApi.GetReferencedByFunc is nil but DefaultApi.GetReferencedBy was called.")
	}

	call := struct {
		Ctx     context.Context
		Subject string
		Version string
	}{
		Ctx:     ctx,
		Subject: subject,
		Version: version,
	}

	m.calls.GetReferencedBy = append(m.calls.GetReferencedBy, call)

	return m.GetReferencedByFunc(ctx, subject, version)
}

// GetReferencedByCalled returns true if GetReferencedBy was called at least once.
func (m *DefaultApi) GetReferencedByCalled() bool {
	m.lockGetReferencedBy.Lock()
	defer m.lockGetReferencedBy.Unlock()

	return len(m.calls.GetReferencedBy) > 0
}

// GetReferencedByCalls returns the calls made to GetReferencedBy.
func (m *DefaultApi) GetReferencedByCalls() []struct {
	Ctx     context.Context
	Subject string
	Version string
} {
	m.lockGetReferencedBy.Lock()
	defer m.lockGetReferencedBy.Unlock()

	return m.calls.GetReferencedBy
}

// GetSchema mocks base method by wrapping the associated func.
func (m *DefaultApi) GetSchema(ctx context.Context, id int32, localVarOptionals *api_default_go.GetSchemaOpts) (api_default_go.SchemaString, *net_http.Response, error) {
	m.lockGetSchema.Lock()
	defer m.lockGetSchema.Unlock()

	if m.GetSchemaFunc == nil {
		panic("mocker: DefaultApi.GetSchemaFunc is nil but DefaultApi.GetSchema was called.")
	}

	call := struct {
		Ctx               context.Context
		Id                int32
		LocalVarOptionals *api_default_go.GetSchemaOpts
	}{
		Ctx:               ctx,
		Id:                id,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.GetSchema = append(m.calls.GetSchema, call)

	return m.GetSchemaFunc(ctx, id, localVarOptionals)
}

// GetSchemaCalled returns true if GetSchema was called at least once.
func (m *DefaultApi) GetSchemaCalled() bool {
	m.lockGetSchema.Lock()
	defer m.lockGetSchema.Unlock()

	return len(m.calls.GetSchema) > 0
}

// GetSchemaCalls returns the calls made to GetSchema.
func (m *DefaultApi) GetSchemaCalls() []struct {
	Ctx               context.Context
	Id                int32
	LocalVarOptionals *api_default_go.GetSchemaOpts
} {
	m.lockGetSchema.Lock()
	defer m.lockGetSchema.Unlock()

	return m.calls.GetSchema
}

// GetSchemaByVersion mocks base method by wrapping the associated func.
func (m *DefaultApi) GetSchemaByVersion(ctx context.Context, subject, version string, localVarOptionals *api_default_go.GetSchemaByVersionOpts) (api_default_go.Schema, *net_http.Response, error) {
	m.lockGetSchemaByVersion.Lock()
	defer m.lockGetSchemaByVersion.Unlock()

	if m.GetSchemaByVersionFunc == nil {
		panic("mocker: DefaultApi.GetSchemaByVersionFunc is nil but DefaultApi.GetSchemaByVersion was called.")
	}

	call := struct {
		Ctx               context.Context
		Subject           string
		Version           string
		LocalVarOptionals *api_default_go.GetSchemaByVersionOpts
	}{
		Ctx:               ctx,
		Subject:           subject,
		Version:           version,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.GetSchemaByVersion = append(m.calls.GetSchemaByVersion, call)

	return m.GetSchemaByVersionFunc(ctx, subject, version, localVarOptionals)
}

// GetSchemaByVersionCalled returns true if GetSchemaByVersion was called at least once.
func (m *DefaultApi) GetSchemaByVersionCalled() bool {
	m.lockGetSchemaByVersion.Lock()
	defer m.lockGetSchemaByVersion.Unlock()

	return len(m.calls.GetSchemaByVersion) > 0
}

// GetSchemaByVersionCalls returns the calls made to GetSchemaByVersion.
func (m *DefaultApi) GetSchemaByVersionCalls() []struct {
	Ctx               context.Context
	Subject           string
	Version           string
	LocalVarOptionals *api_default_go.GetSchemaByVersionOpts
} {
	m.lockGetSchemaByVersion.Lock()
	defer m.lockGetSchemaByVersion.Unlock()

	return m.calls.GetSchemaByVersion
}

// GetSchemaOnly mocks base method by wrapping the associated func.
func (m *DefaultApi) GetSchemaOnly(ctx context.Context, subject, version string, localVarOptionals *api_default_go.GetSchemaOnlyOpts) (string, *net_http.Response, error) {
	m.lockGetSchemaOnly.Lock()
	defer m.lockGetSchemaOnly.Unlock()

	if m.GetSchemaOnlyFunc == nil {
		panic("mocker: DefaultApi.GetSchemaOnlyFunc is nil but DefaultApi.GetSchemaOnly was called.")
	}

	call := struct {
		Ctx               context.Context
		Subject           string
		Version           string
		LocalVarOptionals *api_default_go.GetSchemaOnlyOpts
	}{
		Ctx:               ctx,
		Subject:           subject,
		Version:           version,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.GetSchemaOnly = append(m.calls.GetSchemaOnly, call)

	return m.GetSchemaOnlyFunc(ctx, subject, version, localVarOptionals)
}

// GetSchemaOnlyCalled returns true if GetSchemaOnly was called at least once.
func (m *DefaultApi) GetSchemaOnlyCalled() bool {
	m.lockGetSchemaOnly.Lock()
	defer m.lockGetSchemaOnly.Unlock()

	return len(m.calls.GetSchemaOnly) > 0
}

// GetSchemaOnlyCalls returns the calls made to GetSchemaOnly.
func (m *DefaultApi) GetSchemaOnlyCalls() []struct {
	Ctx               context.Context
	Subject           string
	Version           string
	LocalVarOptionals *api_default_go.GetSchemaOnlyOpts
} {
	m.lockGetSchemaOnly.Lock()
	defer m.lockGetSchemaOnly.Unlock()

	return m.calls.GetSchemaOnly
}

// GetSchemaTypes mocks base method by wrapping the associated func.
func (m *DefaultApi) GetSchemaTypes(ctx context.Context) ([]string, *net_http.Response, error) {
	m.lockGetSchemaTypes.Lock()
	defer m.lockGetSchemaTypes.Unlock()

	if m.GetSchemaTypesFunc == nil {
		panic("mocker: DefaultApi.GetSchemaTypesFunc is nil but DefaultApi.GetSchemaTypes was called.")
	}

	call := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}

	m.calls.GetSchemaTypes = append(m.calls.GetSchemaTypes, call)

	return m.GetSchemaTypesFunc(ctx)
}

// GetSchemaTypesCalled returns true if GetSchemaTypes was called at least once.
func (m *DefaultApi) GetSchemaTypesCalled() bool {
	m.lockGetSchemaTypes.Lock()
	defer m.lockGetSchemaTypes.Unlock()

	return len(m.calls.GetSchemaTypes) > 0
}

// GetSchemaTypesCalls returns the calls made to GetSchemaTypes.
func (m *DefaultApi) GetSchemaTypesCalls() []struct {
	Ctx context.Context
} {
	m.lockGetSchemaTypes.Lock()
	defer m.lockGetSchemaTypes.Unlock()

	return m.calls.GetSchemaTypes
}

// GetSubjectLevelConfig mocks base method by wrapping the associated func.
func (m *DefaultApi) GetSubjectLevelConfig(ctx context.Context, subject string, localVarOptionals *api_default_go.GetSubjectLevelConfigOpts) (api_default_go.Config, *net_http.Response, error) {
	m.lockGetSubjectLevelConfig.Lock()
	defer m.lockGetSubjectLevelConfig.Unlock()

	if m.GetSubjectLevelConfigFunc == nil {
		panic("mocker: DefaultApi.GetSubjectLevelConfigFunc is nil but DefaultApi.GetSubjectLevelConfig was called.")
	}

	call := struct {
		Ctx               context.Context
		Subject           string
		LocalVarOptionals *api_default_go.GetSubjectLevelConfigOpts
	}{
		Ctx:               ctx,
		Subject:           subject,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.GetSubjectLevelConfig = append(m.calls.GetSubjectLevelConfig, call)

	return m.GetSubjectLevelConfigFunc(ctx, subject, localVarOptionals)
}

// GetSubjectLevelConfigCalled returns true if GetSubjectLevelConfig was called at least once.
func (m *DefaultApi) GetSubjectLevelConfigCalled() bool {
	m.lockGetSubjectLevelConfig.Lock()
	defer m.lockGetSubjectLevelConfig.Unlock()

	return len(m.calls.GetSubjectLevelConfig) > 0
}

// GetSubjectLevelConfigCalls returns the calls made to GetSubjectLevelConfig.
func (m *DefaultApi) GetSubjectLevelConfigCalls() []struct {
	Ctx               context.Context
	Subject           string
	LocalVarOptionals *api_default_go.GetSubjectLevelConfigOpts
} {
	m.lockGetSubjectLevelConfig.Lock()
	defer m.lockGetSubjectLevelConfig.Unlock()

	return m.calls.GetSubjectLevelConfig
}

// GetSubjects mocks base method by wrapping the associated func.
func (m *DefaultApi) GetSubjects(ctx context.Context, id int32) ([]string, *net_http.Response, error) {
	m.lockGetSubjects.Lock()
	defer m.lockGetSubjects.Unlock()

	if m.GetSubjectsFunc == nil {
		panic("mocker: DefaultApi.GetSubjectsFunc is nil but DefaultApi.GetSubjects was called.")
	}

	call := struct {
		Ctx context.Context
		Id  int32
	}{
		Ctx: ctx,
		Id:  id,
	}

	m.calls.GetSubjects = append(m.calls.GetSubjects, call)

	return m.GetSubjectsFunc(ctx, id)
}

// GetSubjectsCalled returns true if GetSubjects was called at least once.
func (m *DefaultApi) GetSubjectsCalled() bool {
	m.lockGetSubjects.Lock()
	defer m.lockGetSubjects.Unlock()

	return len(m.calls.GetSubjects) > 0
}

// GetSubjectsCalls returns the calls made to GetSubjects.
func (m *DefaultApi) GetSubjectsCalls() []struct {
	Ctx context.Context
	Id  int32
} {
	m.lockGetSubjects.Lock()
	defer m.lockGetSubjects.Unlock()

	return m.calls.GetSubjects
}

// GetTopLevelConfig mocks base method by wrapping the associated func.
func (m *DefaultApi) GetTopLevelConfig(ctx context.Context) (api_default_go.Config, *net_http.Response, error) {
	m.lockGetTopLevelConfig.Lock()
	defer m.lockGetTopLevelConfig.Unlock()

	if m.GetTopLevelConfigFunc == nil {
		panic("mocker: DefaultApi.GetTopLevelConfigFunc is nil but DefaultApi.GetTopLevelConfig was called.")
	}

	call := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}

	m.calls.GetTopLevelConfig = append(m.calls.GetTopLevelConfig, call)

	return m.GetTopLevelConfigFunc(ctx)
}

// GetTopLevelConfigCalled returns true if GetTopLevelConfig was called at least once.
func (m *DefaultApi) GetTopLevelConfigCalled() bool {
	m.lockGetTopLevelConfig.Lock()
	defer m.lockGetTopLevelConfig.Unlock()

	return len(m.calls.GetTopLevelConfig) > 0
}

// GetTopLevelConfigCalls returns the calls made to GetTopLevelConfig.
func (m *DefaultApi) GetTopLevelConfigCalls() []struct {
	Ctx context.Context
} {
	m.lockGetTopLevelConfig.Lock()
	defer m.lockGetTopLevelConfig.Unlock()

	return m.calls.GetTopLevelConfig
}

// GetTopLevelMode mocks base method by wrapping the associated func.
func (m *DefaultApi) GetTopLevelMode(ctx context.Context) (api_default_go.ModeGetResponse, *net_http.Response, error) {
	m.lockGetTopLevelMode.Lock()
	defer m.lockGetTopLevelMode.Unlock()

	if m.GetTopLevelModeFunc == nil {
		panic("mocker: DefaultApi.GetTopLevelModeFunc is nil but DefaultApi.GetTopLevelMode was called.")
	}

	call := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}

	m.calls.GetTopLevelMode = append(m.calls.GetTopLevelMode, call)

	return m.GetTopLevelModeFunc(ctx)
}

// GetTopLevelModeCalled returns true if GetTopLevelMode was called at least once.
func (m *DefaultApi) GetTopLevelModeCalled() bool {
	m.lockGetTopLevelMode.Lock()
	defer m.lockGetTopLevelMode.Unlock()

	return len(m.calls.GetTopLevelMode) > 0
}

// GetTopLevelModeCalls returns the calls made to GetTopLevelMode.
func (m *DefaultApi) GetTopLevelModeCalls() []struct {
	Ctx context.Context
} {
	m.lockGetTopLevelMode.Lock()
	defer m.lockGetTopLevelMode.Unlock()

	return m.calls.GetTopLevelMode
}

// GetVersions mocks base method by wrapping the associated func.
func (m *DefaultApi) GetVersions(ctx context.Context, id int32) ([]api_default_go.SubjectVersion, *net_http.Response, error) {
	m.lockGetVersions.Lock()
	defer m.lockGetVersions.Unlock()

	if m.GetVersionsFunc == nil {
		panic("mocker: DefaultApi.GetVersionsFunc is nil but DefaultApi.GetVersions was called.")
	}

	call := struct {
		Ctx context.Context
		Id  int32
	}{
		Ctx: ctx,
		Id:  id,
	}

	m.calls.GetVersions = append(m.calls.GetVersions, call)

	return m.GetVersionsFunc(ctx, id)
}

// GetVersionsCalled returns true if GetVersions was called at least once.
func (m *DefaultApi) GetVersionsCalled() bool {
	m.lockGetVersions.Lock()
	defer m.lockGetVersions.Unlock()

	return len(m.calls.GetVersions) > 0
}

// GetVersionsCalls returns the calls made to GetVersions.
func (m *DefaultApi) GetVersionsCalls() []struct {
	Ctx context.Context
	Id  int32
} {
	m.lockGetVersions.Lock()
	defer m.lockGetVersions.Unlock()

	return m.calls.GetVersions
}

// List mocks base method by wrapping the associated func.
func (m *DefaultApi) List(ctx context.Context, localVarOptionals *api_default_go.ListOpts) ([]string, *net_http.Response, error) {
	m.lockList.Lock()
	defer m.lockList.Unlock()

	if m.ListFunc == nil {
		panic("mocker: DefaultApi.ListFunc is nil but DefaultApi.List was called.")
	}

	call := struct {
		Ctx               context.Context
		LocalVarOptionals *api_default_go.ListOpts
	}{
		Ctx:               ctx,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.List = append(m.calls.List, call)

	return m.ListFunc(ctx, localVarOptionals)
}

// ListCalled returns true if List was called at least once.
func (m *DefaultApi) ListCalled() bool {
	m.lockList.Lock()
	defer m.lockList.Unlock()

	return len(m.calls.List) > 0
}

// ListCalls returns the calls made to List.
func (m *DefaultApi) ListCalls() []struct {
	Ctx               context.Context
	LocalVarOptionals *api_default_go.ListOpts
} {
	m.lockList.Lock()
	defer m.lockList.Unlock()

	return m.calls.List
}

// ListVersions mocks base method by wrapping the associated func.
func (m *DefaultApi) ListVersions(ctx context.Context, subject string, localVarOptionals *api_default_go.ListVersionsOpts) ([]int32, *net_http.Response, error) {
	m.lockListVersions.Lock()
	defer m.lockListVersions.Unlock()

	if m.ListVersionsFunc == nil {
		panic("mocker: DefaultApi.ListVersionsFunc is nil but DefaultApi.ListVersions was called.")
	}

	call := struct {
		Ctx               context.Context
		Subject           string
		LocalVarOptionals *api_default_go.ListVersionsOpts
	}{
		Ctx:               ctx,
		Subject:           subject,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.ListVersions = append(m.calls.ListVersions, call)

	return m.ListVersionsFunc(ctx, subject, localVarOptionals)
}

// ListVersionsCalled returns true if ListVersions was called at least once.
func (m *DefaultApi) ListVersionsCalled() bool {
	m.lockListVersions.Lock()
	defer m.lockListVersions.Unlock()

	return len(m.calls.ListVersions) > 0
}

// ListVersionsCalls returns the calls made to ListVersions.
func (m *DefaultApi) ListVersionsCalls() []struct {
	Ctx               context.Context
	Subject           string
	LocalVarOptionals *api_default_go.ListVersionsOpts
} {
	m.lockListVersions.Lock()
	defer m.lockListVersions.Unlock()

	return m.calls.ListVersions
}

// LookUpSchemaUnderSubject mocks base method by wrapping the associated func.
func (m *DefaultApi) LookUpSchemaUnderSubject(ctx context.Context, subject string, body api_default_go.RegisterSchemaRequest, localVarOptionals *api_default_go.LookUpSchemaUnderSubjectOpts) (*net_http.Response, error) {
	m.lockLookUpSchemaUnderSubject.Lock()
	defer m.lockLookUpSchemaUnderSubject.Unlock()

	if m.LookUpSchemaUnderSubjectFunc == nil {
		panic("mocker: DefaultApi.LookUpSchemaUnderSubjectFunc is nil but DefaultApi.LookUpSchemaUnderSubject was called.")
	}

	call := struct {
		Ctx               context.Context
		Subject           string
		Body              api_default_go.RegisterSchemaRequest
		LocalVarOptionals *api_default_go.LookUpSchemaUnderSubjectOpts
	}{
		Ctx:               ctx,
		Subject:           subject,
		Body:              body,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.LookUpSchemaUnderSubject = append(m.calls.LookUpSchemaUnderSubject, call)

	return m.LookUpSchemaUnderSubjectFunc(ctx, subject, body, localVarOptionals)
}

// LookUpSchemaUnderSubjectCalled returns true if LookUpSchemaUnderSubject was called at least once.
func (m *DefaultApi) LookUpSchemaUnderSubjectCalled() bool {
	m.lockLookUpSchemaUnderSubject.Lock()
	defer m.lockLookUpSchemaUnderSubject.Unlock()

	return len(m.calls.LookUpSchemaUnderSubject) > 0
}

// LookUpSchemaUnderSubjectCalls returns the calls made to LookUpSchemaUnderSubject.
func (m *DefaultApi) LookUpSchemaUnderSubjectCalls() []struct {
	Ctx               context.Context
	Subject           string
	Body              api_default_go.RegisterSchemaRequest
	LocalVarOptionals *api_default_go.LookUpSchemaUnderSubjectOpts
} {
	m.lockLookUpSchemaUnderSubject.Lock()
	defer m.lockLookUpSchemaUnderSubject.Unlock()

	return m.calls.LookUpSchemaUnderSubject
}

// Post mocks base method by wrapping the associated func.
func (m *DefaultApi) Post(ctx context.Context) (map[string]string, *net_http.Response, error) {
	m.lockPost.Lock()
	defer m.lockPost.Unlock()

	if m.PostFunc == nil {
		panic("mocker: DefaultApi.PostFunc is nil but DefaultApi.Post was called.")
	}

	call := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}

	m.calls.Post = append(m.calls.Post, call)

	return m.PostFunc(ctx)
}

// PostCalled returns true if Post was called at least once.
func (m *DefaultApi) PostCalled() bool {
	m.lockPost.Lock()
	defer m.lockPost.Unlock()

	return len(m.calls.Post) > 0
}

// PostCalls returns the calls made to Post.
func (m *DefaultApi) PostCalls() []struct {
	Ctx context.Context
} {
	m.lockPost.Lock()
	defer m.lockPost.Unlock()

	return m.calls.Post
}

// Register mocks base method by wrapping the associated func.
func (m *DefaultApi) Register(ctx context.Context, subject string, body api_default_go.RegisterSchemaRequest) (api_default_go.RegisterSchemaResponse, *net_http.Response, error) {
	m.lockRegister.Lock()
	defer m.lockRegister.Unlock()

	if m.RegisterFunc == nil {
		panic("mocker: DefaultApi.RegisterFunc is nil but DefaultApi.Register was called.")
	}

	call := struct {
		Ctx     context.Context
		Subject string
		Body    api_default_go.RegisterSchemaRequest
	}{
		Ctx:     ctx,
		Subject: subject,
		Body:    body,
	}

	m.calls.Register = append(m.calls.Register, call)

	return m.RegisterFunc(ctx, subject, body)
}

// RegisterCalled returns true if Register was called at least once.
func (m *DefaultApi) RegisterCalled() bool {
	m.lockRegister.Lock()
	defer m.lockRegister.Unlock()

	return len(m.calls.Register) > 0
}

// RegisterCalls returns the calls made to Register.
func (m *DefaultApi) RegisterCalls() []struct {
	Ctx     context.Context
	Subject string
	Body    api_default_go.RegisterSchemaRequest
} {
	m.lockRegister.Lock()
	defer m.lockRegister.Unlock()

	return m.calls.Register
}

// TestCompatibilityBySubjectName mocks base method by wrapping the associated func.
func (m *DefaultApi) TestCompatibilityBySubjectName(ctx context.Context, subject, version string, body api_default_go.RegisterSchemaRequest, localVarOptionals *api_default_go.TestCompatibilityBySubjectNameOpts) (api_default_go.CompatibilityCheckResponse, *net_http.Response, error) {
	m.lockTestCompatibilityBySubjectName.Lock()
	defer m.lockTestCompatibilityBySubjectName.Unlock()

	if m.TestCompatibilityBySubjectNameFunc == nil {
		panic("mocker: DefaultApi.TestCompatibilityBySubjectNameFunc is nil but DefaultApi.TestCompatibilityBySubjectName was called.")
	}

	call := struct {
		Ctx               context.Context
		Subject           string
		Version           string
		Body              api_default_go.RegisterSchemaRequest
		LocalVarOptionals *api_default_go.TestCompatibilityBySubjectNameOpts
	}{
		Ctx:               ctx,
		Subject:           subject,
		Version:           version,
		Body:              body,
		LocalVarOptionals: localVarOptionals,
	}

	m.calls.TestCompatibilityBySubjectName = append(m.calls.TestCompatibilityBySubjectName, call)

	return m.TestCompatibilityBySubjectNameFunc(ctx, subject, version, body, localVarOptionals)
}

// TestCompatibilityBySubjectNameCalled returns true if TestCompatibilityBySubjectName was called at least once.
func (m *DefaultApi) TestCompatibilityBySubjectNameCalled() bool {
	m.lockTestCompatibilityBySubjectName.Lock()
	defer m.lockTestCompatibilityBySubjectName.Unlock()

	return len(m.calls.TestCompatibilityBySubjectName) > 0
}

// TestCompatibilityBySubjectNameCalls returns the calls made to TestCompatibilityBySubjectName.
func (m *DefaultApi) TestCompatibilityBySubjectNameCalls() []struct {
	Ctx               context.Context
	Subject           string
	Version           string
	Body              api_default_go.RegisterSchemaRequest
	LocalVarOptionals *api_default_go.TestCompatibilityBySubjectNameOpts
} {
	m.lockTestCompatibilityBySubjectName.Lock()
	defer m.lockTestCompatibilityBySubjectName.Unlock()

	return m.calls.TestCompatibilityBySubjectName
}

// UpdateMode mocks base method by wrapping the associated func.
func (m *DefaultApi) UpdateMode(ctx context.Context, subject string, body api_default_go.ModeUpdateRequest) (api_default_go.ModeUpdateRequest, *net_http.Response, error) {
	m.lockUpdateMode.Lock()
	defer m.lockUpdateMode.Unlock()

	if m.UpdateModeFunc == nil {
		panic("mocker: DefaultApi.UpdateModeFunc is nil but DefaultApi.UpdateMode was called.")
	}

	call := struct {
		Ctx     context.Context
		Subject string
		Body    api_default_go.ModeUpdateRequest
	}{
		Ctx:     ctx,
		Subject: subject,
		Body:    body,
	}

	m.calls.UpdateMode = append(m.calls.UpdateMode, call)

	return m.UpdateModeFunc(ctx, subject, body)
}

// UpdateModeCalled returns true if UpdateMode was called at least once.
func (m *DefaultApi) UpdateModeCalled() bool {
	m.lockUpdateMode.Lock()
	defer m.lockUpdateMode.Unlock()

	return len(m.calls.UpdateMode) > 0
}

// UpdateModeCalls returns the calls made to UpdateMode.
func (m *DefaultApi) UpdateModeCalls() []struct {
	Ctx     context.Context
	Subject string
	Body    api_default_go.ModeUpdateRequest
} {
	m.lockUpdateMode.Lock()
	defer m.lockUpdateMode.Unlock()

	return m.calls.UpdateMode
}

// UpdateSubjectLevelConfig mocks base method by wrapping the associated func.
func (m *DefaultApi) UpdateSubjectLevelConfig(ctx context.Context, subject string, body api_default_go.ConfigUpdateRequest) (api_default_go.ConfigUpdateRequest, *net_http.Response, error) {
	m.lockUpdateSubjectLevelConfig.Lock()
	defer m.lockUpdateSubjectLevelConfig.Unlock()

	if m.UpdateSubjectLevelConfigFunc == nil {
		panic("mocker: DefaultApi.UpdateSubjectLevelConfigFunc is nil but DefaultApi.UpdateSubjectLevelConfig was called.")
	}

	call := struct {
		Ctx     context.Context
		Subject string
		Body    api_default_go.ConfigUpdateRequest
	}{
		Ctx:     ctx,
		Subject: subject,
		Body:    body,
	}

	m.calls.UpdateSubjectLevelConfig = append(m.calls.UpdateSubjectLevelConfig, call)

	return m.UpdateSubjectLevelConfigFunc(ctx, subject, body)
}

// UpdateSubjectLevelConfigCalled returns true if UpdateSubjectLevelConfig was called at least once.
func (m *DefaultApi) UpdateSubjectLevelConfigCalled() bool {
	m.lockUpdateSubjectLevelConfig.Lock()
	defer m.lockUpdateSubjectLevelConfig.Unlock()

	return len(m.calls.UpdateSubjectLevelConfig) > 0
}

// UpdateSubjectLevelConfigCalls returns the calls made to UpdateSubjectLevelConfig.
func (m *DefaultApi) UpdateSubjectLevelConfigCalls() []struct {
	Ctx     context.Context
	Subject string
	Body    api_default_go.ConfigUpdateRequest
} {
	m.lockUpdateSubjectLevelConfig.Lock()
	defer m.lockUpdateSubjectLevelConfig.Unlock()

	return m.calls.UpdateSubjectLevelConfig
}

// UpdateTopLevelConfig mocks base method by wrapping the associated func.
func (m *DefaultApi) UpdateTopLevelConfig(ctx context.Context, body api_default_go.ConfigUpdateRequest) (api_default_go.ConfigUpdateRequest, *net_http.Response, error) {
	m.lockUpdateTopLevelConfig.Lock()
	defer m.lockUpdateTopLevelConfig.Unlock()

	if m.UpdateTopLevelConfigFunc == nil {
		panic("mocker: DefaultApi.UpdateTopLevelConfigFunc is nil but DefaultApi.UpdateTopLevelConfig was called.")
	}

	call := struct {
		Ctx  context.Context
		Body api_default_go.ConfigUpdateRequest
	}{
		Ctx:  ctx,
		Body: body,
	}

	m.calls.UpdateTopLevelConfig = append(m.calls.UpdateTopLevelConfig, call)

	return m.UpdateTopLevelConfigFunc(ctx, body)
}

// UpdateTopLevelConfigCalled returns true if UpdateTopLevelConfig was called at least once.
func (m *DefaultApi) UpdateTopLevelConfigCalled() bool {
	m.lockUpdateTopLevelConfig.Lock()
	defer m.lockUpdateTopLevelConfig.Unlock()

	return len(m.calls.UpdateTopLevelConfig) > 0
}

// UpdateTopLevelConfigCalls returns the calls made to UpdateTopLevelConfig.
func (m *DefaultApi) UpdateTopLevelConfigCalls() []struct {
	Ctx  context.Context
	Body api_default_go.ConfigUpdateRequest
} {
	m.lockUpdateTopLevelConfig.Lock()
	defer m.lockUpdateTopLevelConfig.Unlock()

	return m.calls.UpdateTopLevelConfig
}

// UpdateTopLevelMode mocks base method by wrapping the associated func.
func (m *DefaultApi) UpdateTopLevelMode(ctx context.Context, body api_default_go.ModeUpdateRequest) (api_default_go.ModeUpdateRequest, *net_http.Response, error) {
	m.lockUpdateTopLevelMode.Lock()
	defer m.lockUpdateTopLevelMode.Unlock()

	if m.UpdateTopLevelModeFunc == nil {
		panic("mocker: DefaultApi.UpdateTopLevelModeFunc is nil but DefaultApi.UpdateTopLevelMode was called.")
	}

	call := struct {
		Ctx  context.Context
		Body api_default_go.ModeUpdateRequest
	}{
		Ctx:  ctx,
		Body: body,
	}

	m.calls.UpdateTopLevelMode = append(m.calls.UpdateTopLevelMode, call)

	return m.UpdateTopLevelModeFunc(ctx, body)
}

// UpdateTopLevelModeCalled returns true if UpdateTopLevelMode was called at least once.
func (m *DefaultApi) UpdateTopLevelModeCalled() bool {
	m.lockUpdateTopLevelMode.Lock()
	defer m.lockUpdateTopLevelMode.Unlock()

	return len(m.calls.UpdateTopLevelMode) > 0
}

// UpdateTopLevelModeCalls returns the calls made to UpdateTopLevelMode.
func (m *DefaultApi) UpdateTopLevelModeCalls() []struct {
	Ctx  context.Context
	Body api_default_go.ModeUpdateRequest
} {
	m.lockUpdateTopLevelMode.Lock()
	defer m.lockUpdateTopLevelMode.Unlock()

	return m.calls.UpdateTopLevelMode
}

// Reset resets the calls made to the mocked methods.
func (m *DefaultApi) Reset() {
	m.lockDeleteSchemaVersion.Lock()
	m.calls.DeleteSchemaVersion = nil
	m.lockDeleteSchemaVersion.Unlock()
	m.lockDeleteSubject.Lock()
	m.calls.DeleteSubject = nil
	m.lockDeleteSubject.Unlock()
	m.lockGet.Lock()
	m.calls.Get = nil
	m.lockGet.Unlock()
	m.lockGetClusterId.Lock()
	m.calls.GetClusterId = nil
	m.lockGetClusterId.Unlock()
	m.lockGetMode.Lock()
	m.calls.GetMode = nil
	m.lockGetMode.Unlock()
	m.lockGetReferencedBy.Lock()
	m.calls.GetReferencedBy = nil
	m.lockGetReferencedBy.Unlock()
	m.lockGetSchema.Lock()
	m.calls.GetSchema = nil
	m.lockGetSchema.Unlock()
	m.lockGetSchemaByVersion.Lock()
	m.calls.GetSchemaByVersion = nil
	m.lockGetSchemaByVersion.Unlock()
	m.lockGetSchemaOnly.Lock()
	m.calls.GetSchemaOnly = nil
	m.lockGetSchemaOnly.Unlock()
	m.lockGetSchemaTypes.Lock()
	m.calls.GetSchemaTypes = nil
	m.lockGetSchemaTypes.Unlock()
	m.lockGetSubjectLevelConfig.Lock()
	m.calls.GetSubjectLevelConfig = nil
	m.lockGetSubjectLevelConfig.Unlock()
	m.lockGetSubjects.Lock()
	m.calls.GetSubjects = nil
	m.lockGetSubjects.Unlock()
	m.lockGetTopLevelConfig.Lock()
	m.calls.GetTopLevelConfig = nil
	m.lockGetTopLevelConfig.Unlock()
	m.lockGetTopLevelMode.Lock()
	m.calls.GetTopLevelMode = nil
	m.lockGetTopLevelMode.Unlock()
	m.lockGetVersions.Lock()
	m.calls.GetVersions = nil
	m.lockGetVersions.Unlock()
	m.lockList.Lock()
	m.calls.List = nil
	m.lockList.Unlock()
	m.lockListVersions.Lock()
	m.calls.ListVersions = nil
	m.lockListVersions.Unlock()
	m.lockLookUpSchemaUnderSubject.Lock()
	m.calls.LookUpSchemaUnderSubject = nil
	m.lockLookUpSchemaUnderSubject.Unlock()
	m.lockPost.Lock()
	m.calls.Post = nil
	m.lockPost.Unlock()
	m.lockRegister.Lock()
	m.calls.Register = nil
	m.lockRegister.Unlock()
	m.lockTestCompatibilityBySubjectName.Lock()
	m.calls.TestCompatibilityBySubjectName = nil
	m.lockTestCompatibilityBySubjectName.Unlock()
	m.lockUpdateMode.Lock()
	m.calls.UpdateMode = nil
	m.lockUpdateMode.Unlock()
	m.lockUpdateSubjectLevelConfig.Lock()
	m.calls.UpdateSubjectLevelConfig = nil
	m.lockUpdateSubjectLevelConfig.Unlock()
	m.lockUpdateTopLevelConfig.Lock()
	m.calls.UpdateTopLevelConfig = nil
	m.lockUpdateTopLevelConfig.Unlock()
	m.lockUpdateTopLevelMode.Lock()
	m.calls.UpdateTopLevelMode = nil
	m.lockUpdateTopLevelMode.Unlock()
}
